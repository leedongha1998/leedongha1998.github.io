---
title: "Spring 공부"
categories:
 - Spring
tags: [Spring] 
toc: true
author_profile: true #profile sidebar 감추기
# sidebar:
#     nav: "docs" # 목차 사이드바
search: true #검색 피하기
---

[toc]



#### Mybatis

###### Mybatis란?

{: .notice--info}

데이터의 CRUD를 보다 편하게 사용하기 위해 xml로 구조화된 Mapper 설정 파일을 통해서 JDBC를 구현한 영속성 프레임워크이다.

###### Mybatis 흐름

Controller => Service => DAO => Mybatis설정파일 => DB

![image-20221121214503723](C:\Users\eedon\AppData\Roaming\Typora\typora-user-images\image-20221121214503723.png)

###### Mybatis 동작 구조

Session Factory Builder가 mybatis-config.xml 참조(class의 alias설정, db 연결 설정, sql 구문 경로 설정 등)하여 session factory 생성

----->  Session Factory 가 session 생성 

-----> Session이 mapper.xml 참조(sql 구문 설정(인자값, 결과값, 데이터 타입 등))

-----> (selectOne, selectList, selectMap, insert, delete, update 실행)                                            



###### Mybatis-config 설정하기

1. src/mybatis 폴더를 생성하고, mybatis-config.xml 파일 등록

2. mybatis-config.xml 작성 (mybatis 사이트에서 형식 보고 알맞게 사용)

    <a href="https://mybatis.org/mybatis-3/ko/index.html">마이바티스</a>

3. mapper 파일 생성 및 설정(쿼리 실행이 필요한 model의 위치에 mapper 폴더를 생성하고 식별하기 쉬운 이름으로 파일 등록)



###### mapper 태그

1. resultMap 태그 : 조회한 결과를 객체와 Row간의 1:1 매칭이 아닌, 원하는 객체의 필드에 담아 반환하고자 할 때 사용한다.

   ```java
   <resultMap id="resultMember" type="Member">
       <!-- prop은 필드명, column은 db 컬럼명-->
       <id property="id" column="ID"/>
       <result property="passwd" column="PASSWD"/>
   </resultMap>
   ```

2. select 태그 : sql의 조회 구문을 작성할 때 쓰인다. 해당 쿼리를 외부에서 접근하고자 할 때 namespace.ID명을 적어 접근이 가능하다

   - select 태그의 주요 속성
     - id : 구문을 찾기 위해 사용될 수 있는 네임 스페이스 내 유일한 구분자
     - parameterType : 구문에 전달될 파라미터의 클래스명(패키지 경로 포함)이나 별칭
     - resultType : 리턴되는 타입의 패키지 경로를 포함한 전체 클래스명이나 별칭. collection인 경우, list, arrayList로 설정할 수 있다.
     - resultMap : 사용할 resultMap의 id를 기술한다.

   ```java
   <select id="memberInfo" parameterType="string" resultType="_int"/>
      select * from member where id = #{userid}
   </select>
   ```



###### Mybatis SqlSessionFactory 생성

- Mybatis-config.xml, mapper.xml 파일 생성을 완료했다면, DAO에서 세션 생성을 위한 getSqlSessoinFactory() 메소드를 작성한다.

  ```java
  private SqlSessionFactory getSqlSessoin(){
      
      String resource = "mybatis/mybatis-config.xml";
      SqlSessionFactory factory = null;
      try{
          // mybatis-config.xml의 설정 정보를 inputStream 객체를 통해 읽어와 SqlSessionFactory 객체를 생성한다.
          InputStream inputStream = Resources.getResourceAsStream(resource);
          SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();
          factory = builder.build(inputStream);
      }catch(IOException e){
  
      }
      return factory;
  }
  ```



###### Mybatis SqlSession 생성

- Dao 메소드는 SqlSessionFactory를 사용하여 SqlSession 객체를 생성한다.

  ```java
  public Member selectMember(Member m){
      Member member = null;
      SqlSession session = null;
      
      try{
          // getSqlSessionFactory() 메소드를 통해 세션 정보를 받아와 SqlSession을 생성한다.
          session = getSqlSessionFactory().openSession(false);
          
          // 매퍼 파일 안에 작성된 쿼리문 실행시키고 결과를 받는다.
          member = session.selectOne("Member.loginCheck", m);
          System.out.println(session);
      }catch(Exception e){
          e.printStackTrace();
      }finally{
          session.close();
      }
      return member;
  }
  ```



###### Mybatis 동적 쿼리

{: .notice--info}

일반적으로 검색 기능이나 다중 입력 처리 등을 수행해야 할 경우 sql을 실행하는 dao를 여러 번 호출하거나 batch 기능을 이용하여 버퍼에 담아서 한번에 실행 시키는 방식으로 쿼리를 구현했다면, **마이바티스에서는 이를 동적으로 제어할 수 있는 구문을 제공하여 더 쉽게 쿼리를 구현 할 수 있다.**



###### 지원 구문 종류

1. if 

   ```java
   <select id="searchBoard" resultType="arraylist">
       select * from board
       where writer = 'admin'
       <if test="title != null">
           and title like #{title}
   	</if>
   </select>
   ```

2. choose(when, otherwise) : 주어진 구문 중 한 가지만을 수행하고자 할 때 사용.

   ```java
   <choose>
       <when test="조건식">
       	...
       </when>
       <when test="조건식">
       	...
       </when>
       <otherwise>
       	...
       </otherwise>
   </choose>
   ```

3. trim(where, set)

   - <trim> : 쿼리의 구문의 특정 부분을 없앨 때 사용. 
   - <where> : 기존 쿼리의 where 절을 동적으로 구현할 때 사용.  시작하는 and 나 or 을 제거해준다. where 태그 내부의 if 문이 모두 false 인 경우 where 키워드를 제거해준다.
   - <set> : 기존의 update set 절을 동적으로 구현할 때 사용. 쿼리 실행 시 set을 붙이고 마지막에 끝나는 문장의 ,를 제거한다.

4. foreach

   - 동적 쿼리를 구현할 때 collection에 대한 반복 처리를 제공.

   - foreach태그의 속성

     - item : 반복 될 때 접근 가능한 각 객체 변수

     - index : 반복되는 횟수를 가리키는 변수

     - collection : 반복에 쓰일 Collection 객체

     - open : 첫 반복 시 포함할 여는 문자열 ex) ' ( '

     - close : 마지막 반복 시 포함할 닫는 문자열 ex) ' ) '

     - separator : 반복되는 객체를 나열할 때 사용할 구분자 ex)  ' , '

       ```java
       <select id="searchBadwords" resultType="arraylist">
           select * from board
           where title in
           <foreach item="item" index="index" collection="list" open="(" separator="," close=")">
           	#{item}
       	</foreach>
       </select>
       ```

       



if,when의 test 속성에는 && || < > <= >= 연산자 사용 불가 -> and, or, lt, gt, le, ge 사용할 것



#### Log4j



###### log4j의 레벨들

- fatal : 아주 심각한 에러
- error : 처리 도중 오류(예외) 발생
- warn : 현재 프로그램 실행에는 문제되지는 않지만, 향후 시스템의 잠재적 오류가 될 수 있는 경우
- info : 프로그램 실행 중에 상태변경과 같은 메세지
- debug : 개발 도중 필요한 메세지
- trace : 흐름의 시작과 끝을 정의하는 용도



###### log4j 사용법

<a href="https://cluster-taek.tistory.com/entry/log4j%EC%9D%98-%EA%B0%9C%EB%85%90%EA%B3%BC-%EC%82%AC%EC%9A%A9%EB%B2%95">참고 사이트</a>

```java
// 로그 수집 주체
<logger name = "com.kh.app">
    <level value ="info"/>
</logger>
```



#### MAVEN



###### MAVEN이란?

자바용 프로젝트 관리 도구, (POM) XML 문서를 통해 해당 프로젝트의 버전 정보 및 라이브러리 정보들을 통합하여 관리하는 프레임워크.

지역 저장소에 저장해준다 (C -> 사용자 -> .m2 디렉토리에 저장됨)



###### POM 이란?

{: .notice--info}

POM(Project Object Model)은 하나의 프로젝트에서 사용하는 자바 버전, 라이브러리, 플러그인 구성을 통합하여 관리할 수 있게 각 설정 정보를 xml 문서화 한 것을 말한다.



pom.xml에 의존 등록

```java
<dependencies>

	<dependency>

		여기 위치에 메이븐 사이트에서 의존 붙여넣기

	</dependency>

</dependencies>
```



###### Maven target 폴더

Maven을 사용할 경우 프로젝트 컴파일 시 target/classess 안에 컴파일 된 클래스 파일들이 위치하게 된다.

일반적으로 maven clean 옵션을 사용하면 제거되어 문제는 없지만, 이후 형상관리를 위해 프로젝트를 공유할 시 컴파일 된 결과까지 공유할 필요는 없기 때문에 target 폴더를 공유 목록에서 제외하는 ignore 작업을 설정하자.



###### replection api

jdk의 기본 기능 중 하나. 

- 클래스 객체를 통해서 클래스 정보 열람.

- 객체를 생성.

- 메소드를 호출. 

- 필드 값 제어 처리.



클래스 객체

- 클래스 당 하나 씩 만들어지는 객체로 클래스의 모든 정보를 가지고 있다.
- new 연산자 호출시에도 이 클래스 객체를 베이스로 객체가 생성된다.



**객체 생성**

```java
// 기존 객체 생성
Sample s1 = new Sample();

// 클래스 객체 생성
Class clz1 = Sample.class;
Class clz2 = s1.getClass();
Class clz3 = Class.forName("com.kh.app.reflection.api.Sample"); // 예외 처리해줘야 함.

System.out.print(clz1 == clz2); // true
System.out.print(clz1 == clz3); // true

// 기본 생성자
Constructor<Sample> const1 = clz1.getDeclaredConstructor(null);
Sample s2 = const1.newInstance(null);

//파라미터 생성자
Class[] parameterTypes = {int.class, String.class};
Constructor<Sample> const2 = clz1.getDeclaredConstructor(parmeterTypes);
Object[] initArgs = {100, "helloworld"};
Sample s3 = const2.newInstance(initArgs);
```



###### 메소드 제어

```java
Class<Sample> clz = Sample.class;
Method[] methods = clz.getDeclaredMethods();
for(Method method : methods){
    System.out.println(method);
}

// 하나의 메소드 가져오기
Sample sample = clz.getDeclaredConstructor(null).newInstance(null);

//setNum 메소드 가져오기
Method setNum = clz.getDeclaredMethod("setNum",int.class);
setNum.invoke(sample, 123);

// getNum 메소드 가져오기
Method getNum = clz.getDeclaredMethod("getNum",null);
Object returnValue = getNum.invoke(sample);

System.out.print(returnValue); // 123
System.out.print(sample); // 123
```



###### 필드 제어

```java
Class<Sample> clz =(Class<Sample>)Class.forName("com.kh.app.reflection.api.Sample");

Sample sample = clz.getDeclaredConstructor(int.class, String.class).newInstance(123,"wow");
Field num = clz.getDeclaredField("num");
System.out.println(num); // 필드 정보도 tostring 처리 되어 보여진다.

num.setAccessible(true); // private필드도 접근 가능하게 해준다.

Object value = num.get(sample);
System.out.println(value);

System.out.println(sample); // Sample[num = 123, str = Wow]

```



#### Lombok

###### Lombok 설치

(버전이 안맞아서 적용 안될 수 있으니 주의!)

1. maven repository 에서 lombok 의존 복사
2. pom.xml에 붙여넣기
3. pom.xml에 표시된 lombok 설치된 경로에 가서 jar파일을 복사해서 eclipse 실행 파일에 붙여넣기
4. 해당 경로에서 cmd 열고 java -jar lombo-(버전).jar 실행
5. Specify location 선택 후 eclipse.exe 선택 후 install
6. eclipse 파일 안에 eclipse.ini 마지막 줄에 롬복 설치 문장 추가된 것 확인하기



###### lombok 활용

보통 클래스 레벨에 @Getter, @Setter 등등 어노테이션을 통하여 관리 가능. -> eclipse outline에서 확인 가능

- @Getter
- @Setter
- @NoArgsConstructor
- @AllArgsConstructor
- @ToString
- @Log4j
- @RequiredArgsConstructor : 꼭 필요한 인자만 받는 생성자.



#### Framework

###### Framework란?

{: .notice--info}

소프트웨어를 개발함에 있어 코드를 구현하는 개발 시간을 줄이고, 코드의 재사용성을 증가시키기 위해 일련의 클래스 묶음이나 뼈대, 틀을 제공하는 라이브러리를 구현해 놓은 것.



###### Library란?

{: .notice--info}

다른 프로그램들과 링크되기 위해 존재하는 하나 이상의 서브루틴이나 함수들이 저장된 파일의 모음.



###### Framework 특징

1. 개발자가 따라야 하는 가이드를 제공.
2. 개발할 수 있는 범위가 정해져 있다.
3. 개발자를 위한 다양한 도구, 플러그인 지원



###### Framework 종류

1. 영속성 : 데이터 저장, 조회, 변경, 삭제를 다룸 ex) Mybatis, Hibernate
2. 자바 : Java EE를 통한 웹 어플리케이션 개발에 초점을 맞춤 ex) Spring
3. 화면 구현 : Front-End를 보다 쉽게 구현 ex) Bootstrap, Foundation, react js, vue js
4. 기능 및 지원 : 특정 기능이나 업무 수행에 도움을 줌 ex) Log4j, JUnit 5, ANT



#### Spring Framework



###### Spring 모듈(모듈 : 프로그램을 구성하는 구성 요소로, 관련된 데이터와 함수를 하나로 묶은 단위 의미)

1. spring-beans : 스프링 컨테이너를 이용해서 객체를 생성하는 기본 기능을 제공
2. spring-context : 객체생성, 라이프 사이클 처리, 스키마 확장등의 기능 제공
3. spring-aop : aop 기능 제공
4. spring-web : REST 클라이언트 데이터 변환 처리, 서블릿 필터, 파일 업로드 지원 등 웹 개발에 필요한 기반 기능을 제공
5. spring-webmvc : 스프링 기반의 mvc 프레임워크, 웹 어플리케이션을 개발하는데 필요한 컨트롤러, 뷰 구현을 제공
6. spring-websocket : 스프링 mvc에서 웹 소켓 연동을 처리할 수 있도록 한다.
7. spring-oxm : xml과 자바 객체간의 매핑 처리를 위한 api 제공
8. spring-tx : 트랜잭션 처리를 위한 추상 레이어 제공
9. spring-jdbc : jdbc 프로그래밍을 보다 쉽게 할 수 있는 템플릿 제공
10. spring-orm : 하이버네이트, JPA, Mybatis 등과의 연동을 지원
11. spring-jms : jms 서버와 메세지를 주고 받을 수 있도록 하기 위한 템플릿
12. spring-context-support : 스케쥴링, 메일발송, 캐시연동, 벨로시티 등 부가 기능을 제공



###### Spring MVC 동작 구조

Request -> DispatcherServlet(web.xml) -> HandlerMapping(servlet-context.xml) -> Controller(Controller->Service -> Dao -> db -> Dao -> Service -> Controller) -> DispatcherServlet -> ViewResolver -> view -> Response



1. 클라이언트가 Request요청을 하면 DispatcherServlet이 요청을 가로챈다.(이때 DispatcherServlet이 모든 요청을 가로채는 것이 아닌 web.xml에 <url-patter>에 등록된 내용만 가로챈다.)
2. DispatcherServlet이 가로챈 요청을 HandlerMapping에 보내 해당 요청을 처리할 Controller를 찾는다.
3. 실제 로직 처리
4. 로직 처리 후, DispatcherServlet에 view 이름을 리턴
5. ViewResolver를 통해 결과를 출력할 view 화면을 검색한다.
6. 처리 결과를 view에 송신하고, view 화면을 최종 클라이언트에게 전송



###### 구성 요소

- DispatcherServlet : 클라이언트의 요청을 받음, 요청에 맞는 컨트롤러가 리턴한 결과값을 view에 전달하여 알맞은 응답을 생성.
- HandlerMapping : 클라이언트의 요청 URL을 어떤 컨트롤러가 처리할 지 결정
- Controller : 클라이언트의 요청을 처리한 뒤, 결과를 DispatcherServlet에게 리턴
- ModelAndView : 컨트롤러가 처리한 결과 정보 및 뷰 선택에 필요한 정보를 담는다
- ViewResolver : 컨트롤러의 처리 결과를 생성할 view를 결정
- view : 컨트롤러의 처리 결과 화면을 생성, jsp나 velocity 템플릿 파일 등을 view 로 사용



###### spring 프로젝트 구조

- java 폴더 : 우리가 작성하는 .java 파일의 위치
- resources 폴더: 프로젝트 설정에 필요한 xml 등의 설정파일들
- webapp 폴더 : 사용자 화면에 표시할 view 관련 파일들과 웹 컨테이너 설정에 필요한 xml 파일들
  - webapp폴더 하위의 resources 폴더 : 웹 상에서 사용될 css, js파일을 저장
  - webapp폴더 하위의 classes 폴더 : src에서 작성한 .java 파일을 컴파일하여 만든 .class파일을 저장한다.
  - webapp폴더 하위의 spring 폴더 : spring의 설정 xml 문서들 저장
  - webapp폴더 하위의 views 폴더 : html, jsp 등 사용자 화면에 보여질 웹 문서를 저장한다.
  - web.xml 파일 : 웹 서버에서 사용할 기본 설정 기록





#### Spring IOC

###### IoC 컨테이너

- 스프링에서 관리하는 객체를 Bean이라고 하고, 해당 빈들을 관리한다는 의미로 컨테이너를 Bean Factory 라고 한다.
- <span style="color:red">역할</span> 
  - 객체의 생명주기와 의존성을 관리.
  - VO(DTO/POJO) 객체의 생성, 초기화, 소멸 등의 처리를 관리.
  - 개발자가 직접 객체를 생성할 수 있지만, 해당 권한을 컨테이너에 맡김으로써 소스 코드 구현의 시간 단축을 할 수 있다.



###### IoC 컨테이너와 Bean객체

- Bean 
  - 스프링이 IoC 방식으로 관리하는 Class
  - <span style="color:red">스프링이 직접 생성과 제어를 담당</span>하는 객체
- Bean Factory
  - 스프링의 IoC를 담당하는 핵심 컨테이너
  - <span style="color:red">Bean을 등록,생성,조회,반환</span>하는 기능을 담당
- Application Context
  - BeanFactory를 확장한 IoC 컨테이너
  - Bean을 등록하고 관리하는 기능은 빈팩토리와 동일하지만 스프링이 제공하는 각종 부가 서비스를 추가로 제공
- 설정 메타정보
  - ApplicationContext 또는 BeanFactory가 IoC를 적용하기 위해 사용하는 설정 정보
  - 설정 메타정보는 IoC컨테이너에 의해 관리되는 bean객체를 생성하고 구성할 때 사용



###### Spring DI

- 장점
  - 코드 단순화
  - 객체 간의 종속 관계 해소
- DI의 종류
  - Setter 주입
  - 생성자 의존 주입
  - 필드 주입



###### Spring DI XML

- XML 구조

  - <beans>태그를 최상위로 태그하여 <beans>태그안에 다양한 태그로 값을 설정 가능

- 주요 태그

  - <beans> : xml 파일의 최상위 태그, 여러가지 namespace(p,c,aop,context,tx,mvc 등)를 설정

  - <bean> : 스프링에서 사용할 POJO객체를 컨테이너에 등록하여 컨테이너가 사용할 수 있게 만드는 태그

    - 기본 속성값

      - id="String" : 객체 생성시 사용하는 변수(명명규칙은 카멜케이스 사용)
      - name="String" : 자바 식별자 작성규칙을 따르지 않는다, 특수기호 포함시 사용
      - class="클래스명" : POJO 객체를 지정. 패키지를 포함한 클래스명 작성 ex)com.kh.spring.클래스명

      

    - 기타 속성

      - init-method="메소드명" : 객체 생성 후 초기화 하거나 실행되어야 할 기능이 있는 경우
      - destroy-method="메소드명" : 객체 삭제되기 전에 실행되어야 할 기능이 있는 경우
      - lazy-init="true|false" : 객체가 즉시 로딩되지 않고 사용시 로딩(true)
      - scope="설정값" : 객체 생성 방식을 지정

      

    - <bean>태그 안에 사용가능한 태그들

      - <constructor-arg> : <bean>지정된 객체가 생성될 때 기본생성자가 아닌 매개변수가 있는 생성자로 생성하여 초기값을 대입(일치하는 파라미터 생성자가 있어야 함)
      - <property> : <bean>으로 지정된 객체의 멤버에 값 대입

  - <import> : 설정 파일을 불러오는 태그



###### Spring DI 관리

1. xml 단독 사용

   - 모든 빈을 명시적으로 xml에 등록하는 방법
     - 장점 : 모든 빈을 xml에서 확인 가능, 관리의 편의성이 높다
     - 단점 : 빈 개수가 많아지면 xml 파일을 관리하기 어렵다, 협업시에 설정파일에 충돌 가능, DI에 필요한 적절한 setter메소드 | 생성자가 코드 내부에 반드시 있어야 한다.

2. xml과 어노테이션의 혼용

   - 빈으로 사용될 클래스에 어노테이션을 부여

     - 장점 : 개발 속도 향상, 협업시 설정 파일 충돌 최소화
     - 단점 : 의존관계를 한 눈에 파악하기 어려움

   - 어노테이션 종류

     - @Component : 객체를 나타내는 타입

     - @Repository : 영속성을 가지는 속성(파일, 데이터베이스)을 가진 크래스

     - @Service

     - @Controller

     - @Autowired : 의존관계를 설정한 객체로부터 의존 관계를 자동으로 주입

     - @Qualifier : @Autowired와 함께 쓰며, @Autowired로 DI하고자 하는 객체가 여러개 일 경우 에러가 나기에 @Qualifier("name")을 통해 원하는 객체를 지정하여 주입

       







#### spring legacy project

공부하는 버젼은 sts3 버전이다. -> spring legacy 가능하다 4도 가능하나 플러그인에서 가끔 문제 생길 때가 있다고 한다.

springreload를 사용하기 위해서 jdk 8 버전으로 사용



###### spring legacy project 만들기

1. new -> spring-legacy project 선택
2. templates칸에서 spring mvc project  선택
3. 패키지 작성하는 칸에 3레벨 이상 쓰고 ex) com.kh.spring -> spring이 context-path이다.



###### 초기 설정

1. window -> preferences 에서 인코딩 설정
2. installed JREs java-1.8 설정, compiler 1.8로 변경
3. server runtime 설정에서 tomcat 9.0 버전으로 변경



###### 스프링의 특징

1. 제어의 반전(IoC)
   - 컨트롤의 제어권이 개발자가 아니라 프레임워크에 있다.
   - 객체의 생성부터 모든 생명주기의 관리까지 객체의 제어권이 바뀜
   - 객체를 생성하고, 직접 호출하는 자바프로그램이 아니라, 만들어둔 자원을 프레임워크에서 호출해서 사용
2. 의존성 주입(DI)
   - 객체간의 의존관계를 관리하는 기술
   - 어떤 객체가 필요로 하는 객체를 자기 자신이 직접 생성하는 것이 아니라, 외부에 있는 다른 곳에서 자신이 필요로 하는 객체를 주입 받는 것
3. POJO(Plain)
   - 일반적인 j2ee 프레임워크에 비해 특정 라이브러리를 사용할 필요가 없어서 개발이 쉬우며, 기존 라이브러리 지원이 용이함
4. PSA
   - 스프링은 다른 여러 모듈을 사용함에 있어서 별도의 추상화 레이어 제공 
   - 예를 들어 JPA를 사용할 때에서 Spring JPA를 사용하여 추상화 하므로 실제 구현에 있어서 Hibernate를 사용하든 EclipseLink를 사용하든 사용자는 이 모듈의 의존 없이 프로그램에 집중가능.
5. 관점지향프로그래밍, AOP
   - 트랜잭션, 로깅, 보안 등 여러 모듈, 여러 계층에서 적용되는데, 이런 코드들을 실제 비지니스 로직과 분리
   - 한때, AOP가 OOP(Object Oriented Programming)를 대체하는 기술로 생각되기도 했지만, 실제로 AOP는 OOP를 더욱 OOP스럽게 보완해 주는 기술임.



###### context(bean-manager)

1. xml
2. java annotaion -> @Configuration
3. xml + annotation



###### src/main/webapp 과 src/main/resources

src/main/webapp -> static 파일들 ex) .java .css

src/main/resources -> buildpath



#### spring의 xml파일들

root-context

- mvc 설정과 관련된 여러 처리를 담당하는 설정 파일로 DAO, VO 그리고 Service 등과 같은 파일을 어떻게 사용할 것인가 빈(객체)들을 관리하는 문서
- 빈은 servlet-context에 의해서 참조할 수 없다. 하지만 반대의 경우는 가능하다.
- ex) datasource 빈 등록, mybatis,SqlSessionFactoryBean, SqlSessionTemplate 빈등록, SqlSession 인터페이스 구현체 빈 등록, @Mapper 인터페이스 등록

servlet-context 

- MVC Model의 View와 관련된 객체를 정의한다.
- url과 관련된 Controller, @(Annotation),ViewResolver 등의 설정, Front-End의 설정 파일 느낌이다.

web.xml

- Tomcat과 같은 WAS(Web Application Server)가 최초로 구동될 때, 각종 설정을 정의해주는 파일이다. root-context.xml, servlet-context.xml 같은 설정 파일을 어디서 가져올 것인지 설정해주는 설정을 위한 설정 파일이라고 할 수 있다.

pom.xml

- maven project 생성 시 모듈을 다운받기 위한 xml



#### mybatis-config.xml

```java
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
  PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
  <!-- 
  	자식태그는 다음 순서로 작성할 것!
  	properties?, settings?, typeAliases?, typeHandlers?, objectFactory?, objectWrapperFactory?, 
 	reflectorFactory?, plugins?, environments?, databaseIdProvider?, mappers?
   -->  
  <settings>
  	<setting name="jdbcTypeForNull" value="NULL"/><!-- null데이터 전달시 그대로 null로 대입 -->
  	<setting name="mapUnderscoreToCamelCase" value="true"/>
  </settings>
  
  <typeAliases>
  	<package name="com.kh.spring"/>
  </typeAliases>
  
  <!-- 타입핸들러에 String[]->varchar 위한 설정을 여기에 적어준다. -->
  <typeHandlers>
  	<!-- <typeHandler handler="com.kh.spring.common.typehandler.StringArrayTypeHandler"/> -->
  	<package name="com.kh.spring.common.typehandler"/>
  </typeHandlers>
</configuration>
```



#### Spring 설정

1. 자바 버전 최신화(java1.8, spring5.2.22 release, servlet 4.0.1, jsp 2.3.1)

   ```java
   <properties>
   		<java-version>1.8</java-version>
   		<org.springframework-version>5.2.22.RELEASE</org.springframework-version>
   		<org.aspectj-version>1.6.10</org.aspectj-version>
   		<org.slf4j-version>1.6.6</org.slf4j-version>
   </properties>
       
   <!-- #1.2 serlvet/jsp -->
   		<dependency>
   			<groupId>javax.servlet</groupId>
   			<artifactId>javax.servlet-api</artifactId>
   			<version>4.0.1</version>
   			<scope>provided</scope>
   		</dependency>
   		<dependency>
   			<groupId>javax.servlet.jsp</groupId>
   			<artifactId>javax.servlet.jsp-api</artifactId>
   			<version>2.3.1</version>
   			<scope>provided</scope>
   		</dependency>
   		<dependency>
   			<groupId>javax.servlet</groupId>
   			<artifactId>jstl</artifactId>
   			<version>1.2</version>
   		</dependency>
   ```

2. servlet 버전과 web.xml 버전을 일치시킨다.

3. root-context 설정파일 위치

   ```java
   <context-param>
   		<param-name>contextConfigLocation</param-name>
   		<param-value>/WEB-INF/spring/root-context.xml</param-value>
   </context-param>
   ```

4. 단 하나의 Servlet, DispatcherServlet 하위에서 빈을 관리하는 servlet-context

   ```java
   <servlet>
   		<servlet-name>appServlet</servlet-name>
   		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
   		<init-param>
   			<param-name>contextConfigLocation</param-name>
   			<param-value>/WEB-INF/spring/appServlet/servlet-context.xml</param-value>
   		</init-param>
   		<load-on-startup>1</load-on-startup>
   </servlet>
   		
   <servlet-mapping>
   		<servlet-name>appServlet</servlet-name>
   		<url-pattern>/</url-pattern>
   </servlet-mapping>
   ```

5. encoding filter

   ```java
   <filter>
   		<filter-name>encodingFilter</filter-name>
   		<filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
   		<init-param>
   			<param-name>encoding</param-name>
   			<param-value>utf-8</param-value>
   		</init-param>
   		<init-param>
   			<param-name>forceEncoding</param-name>
   			<param-value>true</param-value>
   		</init-param>
   </filter>
   <filter-mapping>
   		<filter-name>encodingFilter</filter-name>
   		<url-pattern>/*</url-pattern>
   </filter-mapping>
   ```

6. lombok(맨날 작성하는 것들 대신 작성해주는 친구)

   ```java
   <dependency>
   	        <groupId>org.projectlombok</groupId>
   	        <artifactId>lombok</artifactId>
   	        <version>1.18.24</version>
   	        <scope>provided</scope>
   </dependency>
   ```

7. spring-jdbc, mybatis, dbcp, ojdbc8

   ```java
   <dependency>
               <groupId>org.springframework</groupId>
               <artifactId>spring-jdbc</artifactId>
               <version>${org.springframework-version}</version>
   </dependency>
   <dependency>
               <groupId>org.mybatis</groupId>
               <artifactId>mybatis</artifactId>
               <version>3.4.6</version>
   </dependency>
   <dependency>
               <groupId>org.mybatis</groupId>
               <artifactId>mybatis-spring</artifactId>
               <version>1.3.2</version>
   </dependency>
           <!-- Database Connection Pool -->
   <dependency>
               <groupId>commons-dbcp</groupId>
               <artifactId>commons-dbcp</artifactId>
               <version>1.4</version>
   </dependency>
   <dependency>
               <groupId>com.oracle.database.jdbc</groupId>
               <artifactId>ojdbc8</artifactId>
               <version>21.1.0.0</version>
   </dependency>
   ```

8. datasource 빈 등록(root-context.xml에)

   ```java
   <context:property-placeholder location="classpath:datasource.properties"/>
   	<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
   		<property name="driverClassName" value="${datasource.driverClassName}"></property>
   		<property name="url" value="${datasource.url}"></property>
   		<property name="username" value="${datasource.username}"></property>
   		<property name="password" value="${datasource.password}"></property>
   	</bean>
   ```

9. mybatis, SqlSessionFactoryBean, SqlSessionTemplate 빈 등록

   ```java
   <bean id="sqlSessionFactoryBean" class="org.mybatis.spring.SqlSessionFactoryBean">
   		<!-- 여기에서 name dataSource는 setDataSource를 의미하고 ref의 dataSource는 위에 등록한 빈의 아이디이다. -->
   		<property name="dataSource" ref="dataSource"/>
   		<property name="mapperLocations" value="classpath*:mapper/**/*-mapper.xml"/>
   		<property name="configLocation" value="classpath:mybatis-config.xml"/>
   	</bean>
   	<!-- SqlSession인터페이스 구현체. Dao구현 클래스에 의존주입되어 실행된다. -->
   	<bean id="sqlSessionTemplate" class="org.mybatis.spring.SqlSessionTemplate">
   		<constructor-arg ref="sqlSessionFactoryBean" index="0"/>
   	</bean>
   ```

10. @Mapper 인터페이스 등록 : Dao 구현 객체를 동적으로 생성(root-context.xml)

   ```java
   <mybatis-spring:scan base-package="com.kh.spring.**.dao"/>
   ```

11. web.xml에 security-context.xml 등록

    ```java
    	<context-param>
    		<param-name>contextConfigLocation</param-name>
    		<param-value>
    		/WEB-INF/spring/root-context.xml
    		/WEB-INF/spring/security-context.xml
    		</param-value>
    	</context-param>
    ```

12. 암호화 처리 빈 등록(security-context.xml)

    ```java
    <bean id="bcryptPasswordEncoder" class="org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder"></bean>
    ```

13. spring-security 관련 의존 추가

    ```java
    	<dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-core</artifactId>
            <version>${org.springframework.security-version}</version>     
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-web</artifactId>
            <version>${org.springframework.security-version}</version>     
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-config</artifactId>
            <version>${org.springframework.security-version}</version>     
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-taglibs</artifactId>
            <version>${org.springframework.security-version}</version>     
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <version>${org.springframework.security-version}</version>     
        </dependency>        
    ```

14. interceptor 등록(logininterceptor, loginterceptor등을 사용하기 위해서)

    ```java
    <interceptors>
    		<interceptor>
    			<mapping path="/**"/>		
    			<beans:bean id="logInterceptor" class="com.kh.spring.common.interceptor.LogInterceptor"/>
    		</interceptor>
    		
    		<interceptor>
    			<mapping path="/member/memberDetail.do"/>
    			<mapping path="/member/memberUpdate.do"/>
    			<mapping path="/board/**"/>
    			<exclude-mapping path="/board/boardList.do"/>
    			<exclude-mapping path="/board/boardDetail.do"/>
    			<exclude-mapping path="/board/fileDownload.do"/>
    			<beans:bean id="loginInteceptor" class="com.kh.spring.common.interceptor.LoginInterceptor"></beans:bean>
    		</interceptor> 
    	</interceptors>
    ```

15. aop 관련 의존 등록, 트랜잭션 처리 의존

    ```java
    <dependency>
            	<groupId>org.aspectj</groupId>
            	<artifactId>aspectjweaver</artifactId>
           		<version>${org.aspectj-version}</version>
        	</dependency>	
    ```

    

16. aop 관련 어노테이션 등록, root-context의 트랜잭션 관련 처리를 가져와 servlet-context에 적용

    ```java
    <aop:aspectj-autoproxy/>
    ```

17. 파일 업로드 의존

    ```java
    <dependency>
    	        <groupId>commons-io</groupId>
    	        <artifactId>commons-io</artifactId>
    	        <version>2.6</version>
    	    </dependency>
    	    <dependency>
    	        <groupId>commons-fileupload</groupId>
    	        <artifactId>commons-fileupload</artifactId>
    	        <version>1.3.3</version>
    	    </dependency>
    ```

18. multipartResolver 등록

    ```java
    <beans:bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
    		<beans:property name="maxUploadSize" value="5242880"></beans:property> <!-- 50mb 한 건의 파일 요청시 첨부할 파일들의 총 용량 -->
    		<beans:property name="maxUploadSizePerFile" value="10245760"></beans:property><!-- 10mb 한건의 파일당 용량 제한 -->
    		<beans:property name="maxInMemorySize" value="10240"></beans:property><!-- 10kb 이상이면 임시파일을 생성해서 관리하겠다 -->
    	</beans:bean>
    ```

19. jsonView 의존 등록

    ```java
    <dependency>
        <groupId>net.sf.json-lib</groupId>
        <artifactId>json-lib-ext-spring</artifactId>
        <version>1.0.2</version>
    </dependency>
    ```

20. BeanNameResolver viewName에 해당하는 빈을 view로 연결하는 Resolver 등록(servlet-context.xml)

    ```java
    <beans:bean id="viewResolver" class="org.springframework.web.servlet.view.BeanNameViewResolver">
    		<beans:property name="order" value="1"/> <!-- 우선순위 처리해서 위에 있는 뷰 리졸버 보다 먼저 처리되게 함으로 controller에서 "jsonView"라고 리턴해주어도 view/jsonView가 아니게 할 수 있다. -->
    	</beans:bean>
    ```

21.  jackson messageConverter 빈 관련 의존(위 jsonView 보다는 이친구를 사용하는 것을 추천)

    ```java
    <dependency>	
        <groupId>com.fasterxml.jackson.core</groupId>
        <artifactId>jackson-databind</artifactId>
        <version>2.13.3</version>
    </dependency>
        <!-- #13.1 java.time 패키지 클래스를 json변환하기 위한 의존 -->
    <dependency>
        <groupId>com.fasterxml.jackson.datatype</groupId>
        <artifactId>jackson-datatype-jsr310</artifactId>
        <version>2.13.3</version>
    </dependency>
    ```

22. jackson message converter bean 등록(servlet-context.xml)

    ```java
    <beans:bean id="jacksonMessageConverter" class="org.springframework.http.converter.json.MappingJackson2HttpMessageConverter"/>
    ```

23. security filter chain 등록(web.xml)

    ```java
    <filter>
            <filter-name>springSecurityFilterChain</filter-name>
            <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>
        </filter>
        <filter-mapping>
            <filter-name>springSecurityFilterChain</filter-name>
            <url-pattern>/*</url-pattern>
        </filter-mapping>
    ```

    





#### @Controller 클래스의 핸들러 메소드가 가질 수 있는 매개변수 타입

- HttpServletRequest
- HttpServletResponse
- HttpSession
- java.util.Locale : 요청에 대한 Local
- InputStream/Reader : 요청에 대한 입력 스트림
- OutputStream/Writer : 응답에 대한 출력 스트림



사용자 입력값 처리

- Command 객체 : http요청 파라미터를 커맨드객체에 저장한 VO객체
- CommandMap : HandlerMethodArgumentResolver에 의해 처리된 사용자 입력값을 가진 Map객체
- @Valid : 커맨드 객체 유효성 검사 객체
- Error,BildingResult : Command객체에 저장결과(Command객체 바로 다음 위치시킬 것)
- @PathVariable : 요청 url중 일부를 매개변수로 취할 수 있다.
- @RequestParam : 사용자 입력값을 자바변수에 대입 처리(필수 여부 설정)
- @RequestHeader : 헤더값
- @CookieValue : 쿠키값
- @RequestBody : http message body에 작성된 json을 vo객체로 변환 처리



뷰에 전달할 모델 데이터 설정

- ModelAndView
- ModelMap
- Model
- @ModelAttribute : model속성에 대한 getter
- @SessionAttribute : session속성에 대한 getter(required 여부 선택 가능)
- SessionStatus : @SessionAttributes로 등록된 속성에 대하여 사용완료 처리. 세션을 폐기하지 않고 처리.



기타

- MultipartFile : 업로드파일 처리 인터페이스
- RedirectAttributes : DML 처리 후 요청 주소 변경을 위한 redirect시 속성처리 지원



#### Controller(초기)

```java
@Controller
@RequestMapping("/demo") // requestMapping을 클래스 레벨에 작성하여 중복되는 url처리 해줌.
public class DemoController {
	
	static final Logger log = LoggerFactory.getLogger(DemoController.class);
	
	@Autowired
	private DemoService demoService;
	
	/**
	 * value = path에 대한 별칭
	 * method : 작성하지 않으면 모든 전송방식을 허용 
	 */
	@RequestMapping(path="/devForm.do", method = RequestMethod.GET)
	public String devForm() {
		log.info("{} 요청이 들어왓습니다","/demo/devForm.do");
		return "demo/devForm";
	}
	
	@RequestMapping(path="/dev1.do", method = RequestMethod.POST)
	public String dev1(HttpServletRequest request, HttpServletResponse response) {
		String name = request.getParameter("name");
		int career = Integer.parseInt(request.getParameter("career"));
		String email = request.getParameter("email");
		String _gender = request.getParameter("gender");
		Gender gender = _gender != null ? Gender.valueOf(_gender) : null;
		String[] lang = request.getParameterValues("lang");
		
		Dev dev = new Dev(0, name, career, email, gender, lang, LocalDateTime.now());
		
		log.info("dev = {}",dev);
		
		request.setAttribute("dev", dev);
		
		return "demo/devResult";
	}
	
	/**
	 * 
	 * @RequestParam
	 * - 모든 필드는 필수값(기본값)
	 * - required = false (옵션으로 처리)
	 * - 자바 변수명, name속성값과 일치하는 사용자 입력값을 찾는다.
	 * - 기본값 처리도 가능하다.
	 * -> requestparam은 꼭 받아야 하는 값처리할 때 사용하는 것이 좋다.
	 */
	@RequestMapping(path="/dev2.do", method = RequestMethod.POST)
	public String dev2(
			// view 단 폼에서 name 속성이랑 일치하는 것으로 매칭한다.
			@RequestParam(required=false, defaultValue="홍길동") String nm,
			@RequestParam int career,
			@RequestParam String email,
			@RequestParam(required=false) Gender gender,
			@RequestParam String[] lang,
			Model model
			) {
		
		Dev dev = new Dev(0, nm, career, email, gender, lang, LocalDateTime.now());
		log.info("dev={}",dev);
		
		// view 단에 전달한 데이터를 model에 속성으로 추가 -> request scope에 속성으로 저장
		model.addAttribute("dev",dev);
		
		return "demo/devResult";
	}
	
	/**
	 * 
	 * 커맨드 객체
	 * - 사용자 입력 name값 - property(setter)가 일치하면 값대입
	 * - 자동으로 model속성으로 등록된다.
	 */
	@RequestMapping(path="/dev3.do" , method=RequestMethod.POST)
	public String dev3(Dev dev // 위 메소드 처럼 리퀘스트파람으로 받아오는 방법 대신 dev객체로 받았다) {
		log.info("dev={}",dev);
		
		return "dev/devResult";
	}
	
	@RequestMapping(path="/insertDev.do", method = RequestMethod.POST)
	public String insertDev(Dev dev, RedirectAttributes redirectAttr) {
		int result = demoService.insertDev(dev);
		
		redirectAttr.addFlashAttribute("msg","개발자 등록 성공!");
		return "redirect:/";
	}
	
	@RequestMapping(path="/devList.do", method=RequestMethod.GET)
	public String devList(Model model) {
		List<Dev> list = demoService.selectDevList();
		log.info("list={}",list);
		model.addAttribute("list",list);
		return "demo/devList";
    }
}

```



#### Controller 중기

{: .notice--info}

기존에는 @RequestMapping을 통하여 url매핑을 해줬다면, @Get/@PostMapping을 통하여 메소드 타입에 맞게 설정해줌



###### key point

- @GetMapping, @PostMapping
- model 객체를 통해 session에 저장하려면 클래스 레벨에 @SessionAttributes를 통하여 세션에 저장
  -  @SessionAttributes로 세션관리를 한다면, SessionStatus#setComplete로 만료처리해야 한다.
- @slf4j 를 통해 로그 출력 -> log4j.xml에서 로그레벨 설정
- BCryptPasswordEncoder를 의존 주입 받아서 비밀번호 암호화
- viewName이 null인 경우 요청 url을 기준으로 jsp 위치를 추론한다.

```java
package com.kh.spring.member.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.SessionAttributes;
import org.springframework.web.bind.support.SessionStatus;
import org.springframework.web.servlet.mvc.support.RedirectAttributes;

import com.kh.spring.member.model.dto.Member;
import com.kh.spring.member.model.service.MemberService;

import lombok.extern.slf4j.Slf4j;

@Controller
@RequestMapping("/member")
@Slf4j
@SessionAttributes({"loginMember"})
public class MemberController {

//	static final Logger log = LoggerFactory.getLogger(MemberController.class);
	
	@Autowired
	private MemberService memberService;
	
	@Autowired
	private BCryptPasswordEncoder bcryptPasswordEncoder;
	
	//@RequestMapping(path="/member/memberEnroll.do",method=RequestMethod.GET)
	@GetMapping("/memberEnroll.do")
	public String memberController() {
		return "member/memberEnroll";
	}
	
	/**
	 * $2a$10$2.AdYu08nfVhU89v8PyfsuF0kObCQvGCdJiR3I5p1dSQMY81FfD6O
	 * 
	 * - $2a$ 알고리즘타입
	 * - 10$ 옵션 (비용이 높을수록 속도가 오래걸리고, 메모리사용량이 많다)
	 * - 2.AdYu08nfVhU89v8Pyfsu 22자리 random salt
	 * - F0kObCQvGCdJiR3I5p1dSQMY81FfD6O 31자리 hashing + encoding처리
	 * 
	 */
	@PostMapping("/memberEnroll.do")
	public String memberEnroll(Member member, RedirectAttributes redirectAttr) {
		try {
			log.debug("member = {}", member);
			
			// 비밀번호 암호화
			String rawPassword = member.getPassword();
			String encodedPassword = bcryptPasswordEncoder.encode(rawPassword);
			member.setPassword(encodedPassword);
			log.debug("encodedPassword = {}", encodedPassword);
			
			int result = memberService.insertMember(member);
			redirectAttr.addFlashAttribute("msg", "회원 가입이 정상적으로 처리되었습니다.");
			return "redirect:/";
		} catch(Exception e) {
			log.error("회원등록 오류 : " + e.getMessage(), e);
			throw e;
		}
	}
	/**
	 * viewName이 null인 경우 요청 url을 기준으로 jsp 위치를 추론한다.
	 *  -> member/memberLogin 
	 *
	 */
	@GetMapping("/memberLogin.do")
	public void memberLogin() {
		
	}
	
	@PostMapping("/memberLogin.do")
	public String memberLogin(@RequestParam String memberId,
                              @RequestParam String password,
                              RedirectAttributes redirectAttr,
                              Model model) {
		
		// 1. memberId로 회원 조회
		Member member = memberService.selectOneMember(memberId);
		log.debug("member = {}",member);
		
		String location = "/";
		// 2. member가 null이 아니면서, 비밀번호가 일치하면 로그인
		if(member != null && bcryptPasswordEncoder.matches(password, member.getPassword())) {
			// model을 통해 session scope에 속성 저장 : 클래스 레벨에 @SessionAttributes
			model.addAttribute("loginMember",member);
		}else {
			redirectAttr.addFlashAttribute("msg","회원 정보가 일치하지 않습니다.");
			location = "/member/memberLogin.do";
		}
		return "redirect:" + location;
	}
	
	/**
	 * @SessionAttributes로 세션관리를 한다면, SessionStatus#setComplete로 만료처리해야 한다.
	 * 
	 */
	@GetMapping("/memberLogout.do")
	public String memberLogout(SessionStatus sessionStatus) {
		
		if(!sessionStatus.isComplete())
			sessionStatus.setComplete();
		
		return "redirect:/";
	}
}
```



#### Model

{: .notice--info}

mvc의 model이 아닌 view 단에 데이터를 전달하기 위한 임시 저장소, Map 객체.



- ModelAndView
  - model - addObject
  - view - setView(View) | setViewName(String)
- ModelMap
  - model -addAttribute
  - view 없음. handler에서 view정보를 문자열로 반환해야 함.
- Model
  - model - addAttribute
  - view 없음. handler에서 view 정보를 문자열로 반환해야 함.



###### 관련 어노테이션

- @ModelAttribute

  - 메소드 레벨 -  해당 컨트롤러의 전역 모델 속성 등록

  - 메소드 매개변수에 작성 - 모델 속성에 대한 getter

  - ```java
    // /demo로 시작하는 url 요청이 왔을 때 common이라는 값에 email, tel값 담을 수 있다. 따라서 /demo로 시작하는 view단에 ${common.email}. ${common.tel}을 통해 값 확인 가능
    @ModelAttribute("common")
    	public Model common(Model model) {
    		log.debug("@ModelAttribute - common 호출!");
    		model.addAttribute("email","admin@kh.com");
    		model.addAttribute("tel","010-1233-2222");
    		return model;
    	}
    ```

- @SessionAttribute : 메소드 매개변수에 작성. session scope에 저장된 속성에 대한 getter

- @SessionAttributes : 클래스 레벨, session scope에 저장된 속성명 관리





#### java 타입을 db에 넣기 위한 핸들러(String[] -> varchar)

```java
@MappedTypes(String[].class) // java type 작성
@MappedJdbcTypes(JdbcType.VARCHAR) // jdbc type 작성
// 핸들러 생성할 때 BaseTypeHandler 상속받을 것!!!!
public class StringArrayTypeHandler extends BaseTypeHandler<String[]> {
	/**
	 * String[] -> varchar
	 * - parameter가 null인 경우는 호출되지 않는다.
	 */
	@Override
	public void setNonNullParameter(PreparedStatement ps, int i, String[] parameter, JdbcType jdbcType)
			throws SQLException {
		String value = String.join(", ", parameter); // C, Java
		ps.setString(i, value);
	}

	/**
	 * varchar -> string[]
	 */
	@Override
	public String[] getNullableResult(ResultSet rs, String columnName) throws SQLException {
		String value = rs.getString(columnName);
		return value != null ? value.split(",") : null;
	}

	@Override
	public String[] getNullableResult(ResultSet rs, int columnIndex) throws SQLException {
		String value = rs.getString(columnIndex);
		return value != null ? value.split(",") : null;
	}

	@Override
	public String[] getNullableResult(CallableStatement cs, int columnIndex) throws SQLException {
		String value = cs.getString(columnIndex);
		return value != null ? value.split(",") : null;
	}

}

```



#### Member DTO

```java
package com.kh.spring.member.model.dto;

import java.time.LocalDate;
import java.time.LocalDateTime;

import org.springframework.format.annotation.DateTimeFormat;

import com.kh.spring.demo.model.dto.Gender;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.NonNull;

@Data // @Data(@Getter, @Setter, @ToString, @EqualsAndHashCode, @RequiredArgsConstructor 포함)
@NoArgsConstructor
@AllArgsConstructor
public class Member {
	@NonNull
	private String memberId;
	@NonNull
	private String password;
	@NonNull
	private String name;
	private Gender gender;
	@DateTimeFormat(pattern = "yyyy-MM-dd")
	private LocalDate birthday;
	private String email;
	@NonNull // 필드에 직접 어노테이션을 붙여 not null 설정
	private String phone;
	private String address;
	private String[] hobby;
	private LocalDateTime createdAt;
	private LocalDateTime updatedAt;
	private boolean enabled; // db에는 1,0으로 true,false
}
```



###### LocalDate, LocalDateTime,@DateTimeFormat

- LocalDate

  - 날짜 정보만 필요할 때 사용

  - ```java
    LocalDate currentDate = LocalDate.now();
    LocalDate targetDate = LocalDate.of(2019,11,12);
    // 결과 : 2019-11-12
    ```

- LocalDateTime

  - 날짜와 시간 정보 모두 필요할 때 사용

  - ```java
    / 로컬 컴퓨터의 현재 날짜와 시간 정보
    LocalDateTime currentDateTime = LocalDateTime.now();    
    // 결과 : 2019-11-12T16:34:30.388
    
    LocalDateTime targetDateTime = LocalDateTime.of(2019, 11, 12, 12, 32,22,3333);
    // 여기도 second,nanoSecond 매개변수는 필수가 아닌 선택입니다.
    // 결과 : 2019-11-12T12:32:22.000003333
    ```

- @DateTimeFormat(pattern = "yyyy-MM-dd")

  - db에서 String으로 들어오는 날짜 정보를 해당 형식으로 바꿔 날짜 관련 타입으로 바꾸어 줄 때 사용.



#### Modal(bootstrap)

부트스트랩에서 모달 코드를 넣고 실행하려면 스크립트 태그 안에 아래 코드를 작성해주어야 작동된다.

```java
<script>
$(loginModal).modal()
		// hide.bs.modal은 bootstrap에서 만든 것.
		.on("hide.bs.modal", (e) => {
			location.href = "${pageContext.request.contextPath}";
		});
</script>
```



#### view 단(jsp)

##### \<jsp:include>

현재 페이지에 다른 파일을 가져올 수 있다.

```java
<jsp:include page="/WEB-INF/views/common/header.jsp">
	<jsp:param value="회원등록" name="title"/>
</jsp:include>
```



##### <% %> 스크립트릿 태그

html 코드안에 자바 코드를 사용할 수 있게 해주는 태그



##### <%= 표현식 태그 %>

실제 모습은 <% out.print();%> 이기 때문에 사용 시 마지막에 ; 없이 작성



#### Spring AOP(Aspect Oriented Progarmming)

{: .notice--info}

관점지향 프로그래밍, 관심사의 분리해서 필요한 주업무에 모듈 형식으로 삽입해 실행.



###### 개념

AOP는 OOP를 대신하는 새로운 개념이 아니라, OOP를 더욱 OOP 답게 사용할 수 있도록 도와주는 개념이다.

- 객체를 재사용함으로써, 개발자들은 반복되는 코드를 줄였지만, 매 요청마다 로그, 권한 체크, 인증, 예외 처리 등 필수 요소는 반복 될 수 밖에 없음
- AOP를 통해, 비지니스 로직과 공통 모듈로 구분한 후에 비지니스 로직 코드 외부에서 필요한 시점에 공통 모듈을 삽입하여 실행하게 함.
- 기존 프로그래밍에서 각 객체별로 처리했던 것을 AOP에서는 각 관점별로 외부에서 접근해 처리하게 됨
- 즉 개발자는 계정, 게시판, 계좌이체와 같은 주업무 기능과, 공통적인 관심을 처리하는 보조 업무 기능을 각각 모듈로써 분리/개발한 후, 필요한 시점에 자동으로 소스코드가 삽입되도록 함.



**Aspect**(Advice와 pointcut을 작성하는 클래스 느낌이다.)

- 구현하고자 하는 횡단 관심사의 기능. 클래스 단위, 한개 이상의 Pointcut과 Advice의 조합으로 만들어진다.



**Joinpoint**(주 업무 로직의 메소드)

- 관점을 삽입하여 Advice가 적용될 수 있는 위치로써, 주업무 처리 메소드를 가리킨다.
- 대표적인 조인 포인트
  - 메소드가 호출되는 부분 또는 리턴되는 부분
  - 인스턴스가 만들어지는 지점
  - 예외가 던져지는 지점
  - 클래스가 초기화 되는 곳



**Pointcut**(어디에 삽입 결정)

- 어느 클래스의 어떤 메소드, 어느 joinpoint에 사용할 것인가?
- AOP에서는 포인트컷을 수행할 수 있는 다양한 접근 방법을 제공하는데, AspectJ에서는 와일드카드를 이용한 메쏘드 시그니처를 사용한다. 
- `execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern) throws-pattern?)`



**Advice**(처리할 부가 업무)

- 각 조인포인트에 삽입되어져 동작할 수 있는 코드
- 주로 메소드 단위로 구성된 어드바이스는 포인트컷에 의해 결정된 모듈의 조인포인트에서 호출되어 사용됨
- 일반적으로 독립적인 클래스 등으로 구현된 횡단 관심 모듈을 조인포인트의 정보를 참조해서 이용하는 방식으로 작성된다.
- Advice 종류
  - Before Advice : joinpoint 전에 실행
  - Around Advice : joinpoint 앞과 뒤에서 실행, 위치가 자유롭다
  - After Returning Advice : joinpoint 메소드가 리턴될 시 실행. return 된 object에 접근 가능
  - After Advice : jointpoint 후에 무조건 실행됨
  - After Throwing Advice : joinpoint 메소드 실행 중 예외 발생시 실행



**Weaving**

pointcut에 의해서 결정된 jointpoint에 지정된 Advice를 삽입하는 과정

- weaving 하는 3가지 방법
  - 컴파일 시에 
  - 클래스 로딩 시에
  - 런타임 시에





###### 선언식에서의 표현

`<aop:config>` 태그 몸체에서 작성하고, advisor 태그 혹은 aspect태그로 작성할 수 있음

1. `<aop:advisor>` : 1 advice + 1 pointcut

   - pointcut : 상기 표현식으로 joinpoint를 선정함

   - pointcut-ref : 선언된 pointcut을 이름으로 참조함

   - ```java
     <aop:config>
       	<aop:advisor
       		pointcut="com.xyz.someapp.SystemArchitecture.businessService()"
       		advice-ref="some-advice"/>
     </aop:config>
     ```

2. `<aop:aspect>` : multiple pointcut + multiple advice

   - aop:aspect는 등록된 특정 Aspect빈(클래스)을 참조함.(@Aspect 어노테이션 선언과 동일함.)

   - ```java
      <aop:config>
       	<aop:aspect id="loggerAspect" ref="loggerAspect">
       		<aop:pointcut expression="execution(* com.kh.spring.memo..*(..))" id="pc"/>
       		<aop:around method="aroundAdvice" pointcut-ref="pc"/>
       		<aop:before method="beforeAdvice" pointcut-ref="pc"/>
       	</aop:aspect>
     </aop:config>
     ```

3. `<aop:pointcut>` : pointcut 표현식 이용

   - ```java
     <aop:config>
      	<aop:pointcut id="businessService"
      		expression="execution(* com.xyz.myapp.service.*.*(..))"/>
      </aop:config>





###### Pointcut 선언

Pointcut은 Aspectj를 통해 와일드카드를 이용한 다음 표현식을 지원함.(&&, ||, !(부정)를 지원함.)



1. execution pointcut designator

   `execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern) throws-pattern?)`

```java
@Pointcut("execution(public * *(..))")
private void anyPublicOperation() {}
```



2. within pointcut designator

   ```java
   @Pointcut("within(com.xyz.someapp.trading..*)")
   private void inTrading() {}
   ```

   

3. name pointcut designator(다른 pointcut을 이름으로 참조함)

   ```java
   @Pointcut("anyPublicOperation() && inTrading()")
   private void tradingOperation() {}
   ```

   

<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/aop.html#aop-pointcuts-examples">pointcut 예제</a>



###### 사용자 입력값 처리

```java
@Component
@Aspect
@Slf4j
public class EscapeXmlAspect {

	@Pointcut("execution(* com.kh.spring.todo.controller.TodoController.todoList(..))")
	public void pc() {
		
	}
	
	@AfterReturning(pointcut="pc()",returning = "returnObj")
	public void escapeXml(JoinPoint jointPoint, Object returnObj) {
		ModelAndView mav = (ModelAndView) returnObj;
		log.debug("mav = {}",mav);
		
		Map<String,Object> model = mav.getModel();
		List<Todo> list = (List<Todo>) model.get("list");
		for(Todo todo : list) {
			String maybeXss = todo.getTodo();
			String safeXss = escapeXmlProcess(maybeXss);
			todo.setTodo(safeXss);
		}
		
	}

    // 사용자가 <script>alert("메롱")</script> 같이 입력하여 페이지를 조작하는 것을 막기 위해 변환 처리
	private String escapeXmlProcess(String maybeXss) {
		return maybeXss.replaceAll("<", "&lt;").replaceAll(">", "&gt;");
	}
}

```





#### DTO(BoardEntity, Board, Attachment)

**Board**

```java
@Data
@NoArgsConstructor
@ToString(callSuper = true) // 부모까지 호출하겠다는 옵션
public class Board extends BoardEntity {
	
	private int attachCount;
	private List<Attachment> attachments = new ArrayList<>(); // 게시글 하나에 여러 첨부파일이 오는 구조라서 필드로 선언해주었다.
	
	public Board(int no, String title, String memberId, String content, int readCount, LocalDateTime createdAt,
			LocalDateTime updatedAt, int attachCount) {
		// lombok은 아래 코드를 자동 생성해 주지 않기 때문에 직접 만들어 줘야 한다.
		super(no, title, memberId, content, readCount, createdAt, updatedAt);
		this.attachCount = attachCount;
	}
	
	// attachment에 추가하는 일을 여기서 하겠다.
	public void add(Attachment attach) {
		this.attachments.add(attach);
	}
}
```



**BoardEntity**(실제 db의  Board테이블과 일치하는 dto 클래스)

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class BoardEntity {

	private int no;
	private String title;
	private String memberId;
	private String content;
	private int readCount;
	private LocalDateTime createdAt;
	private LocalDateTime updatedAt;
	
}
```



**Attachment**(첨부파일)

```java
@Data
@NoArgsConstructor
@RequiredArgsConstructor // not null 인 친구들의 생성자
@AllArgsConstructor
public class Attachment {

	private int no;
	private int boardNo;
	@NonNull
	private String originalFileName;
	@NonNull
	private String renamedFileName;
	private int downloadCount;
	private LocalDateTime createdAt;
}
```







#### 마이바티스 페이징 처리

RowBounds 객체 사용



**HelloSpringUtils**(이 클래스에서 페이징 처리)

```java
/**
	 * 
	 * totalPage : 전체 페이지 수
	 * pagebarSize : 페이지 바에 몇개의 숫자를 나열할 거냐
	 * pageNo : 증감 변수
	 * pagebarStart : 증감 시작
	 * pagebarEnd : 증감 끝
	 * 
	 */
	public static String getPagebar(int cPage, int limit, int totalContent, String url) {
		StringBuffer pagebar = new StringBuffer();
		url += "?cPage="; // /spring/board/boardList.do?cPage=
		
		final int pagebarSize = 5;
		final int totalPage = (int)Math.ceil((double)totalContent / limit);
		final int pagebarStart = ((cPage - 1) / pagebarSize) * pagebarSize + 1;
		final int pagebarEnd = pagebarStart + pagebarSize - 1;
		int pageNo = pagebarStart;
		
	
		pagebar.append("<ul class=\"pagination justify-content-center\">\r\n");
		
		// 1. previous
		if(pageNo == 1) {
			pagebar.append("<li class=\"page-item disabled\">\r\n"
					+ "	      <a class=\"page-link\" href=\"#\" tabindex=\"-1\">Previous</a>\r\n"
					+ "	    </li>\r\n");
		}else {
			pagebar.append("<li class=\"page-item\">\r\n"
					+ "	      <a class=\"page-link\" href=\"" + url + (pageNo - 1)+ "\" tabindex=\"-1\">Previous</a>\r\n"
					+ "	    </li>\r\n");
		}
		
		
		// 2. pageNo
		while(pageNo <= pagebarEnd && pageNo <= totalPage) {
			// 현재 페이지인 경우
			if(pageNo == cPage) {
				pagebar.append("<li class=\"page-item active\"><a class=\"page-link\" href=\"#\">"+ pageNo +"</a></li>\r\n");
			}else {
				pagebar.append("<li class=\"page-item\"><a class=\"page-link\" href=\"" + url + pageNo +"\">"+pageNo+"</a></li>\r\n");
			}
			
			pageNo++;
		}
		
		// 3. next
		
		if(pageNo > totalPage) {
			pagebar.append("	    <li class=\"page-item disabled\">\r\n"
					+ "	      <a class=\"page-link\" href=\"#\">Next</a>\r\n"
					+ "	    </li>\r\n"
					+ "	  </ul>\r\n");
		}else {
			pagebar.append("	    <li class=\"page-item\">\r\n"
					+ "	      <a class=\"page-link\" href=\""+ url + pageNo +"\">Next</a>\r\n"
					+ "	    </li>\r\n"
					+ "	  </ul>\r\n");
        }
		pagebar.append("</ul>");
		
		return pagebar.toString();
	}
```





**controller**

```java
@GetMapping("/boardList.do")
	public void boardList(Model model, @RequestParam(defaultValue = "1") int cPage, HttpServletRequest request) {
		// 1. content 영역
		Map<String, Integer> param = new HashMap<>();
		int limit = 10;
		param.put("cPage", cPage);
		param.put("limit", limit);
		List<Board> list = boardService.selectBoardList(param);
		log.debug("board={}",list);
		model.addAttribute("list",list);
		
		// 2. 페이지바 영역
		int totalContent = boardService.getTotalContent();
		log.debug("totalContent={}",totalContent);
		
		String url = request.getRequestURI(); // /spring/board/boardList.do
		String pagebar = HelloSpringUtils.getPagebar(cPage,limit,totalContent,url);
		model.addAttribute("pagebar",pagebar);
	}
```



**serviceImpl**

```java
@Override
	public List<Board> selectBoardList(Map<String,Integer> param) {
	// mybatis에서 제공하는 페이징 처리 객체 RowBounds
	// offset limit
	int limit = param.get("limit");
	int offset = (param.get("cPage")-1) * limit;
	RowBounds rowBounds = new RowBounds(offset,limit);
	
	return boardDao.selectBoardList(rowBounds);
	}
```



###### 파일 업로드 처리

**Controller**

```java
@PostMapping("/boardEnroll.do")
	public String boardEnroll(Board board, @RequestParam(name = "upFile") List<MultipartFile> upFileList, RedirectAttributes redirectAttr) throws IllegalStateException, IOException {
		log.debug("board={}",board);
		
		for(MultipartFile upFile : upFileList) {
//			log.debug("upFile={}",upFile);
//			log.debug("upFile#name={}",upFile.getName()); // upFile, 만약 파일을 첨부하지 않아도 null 값이 아닌 빈 값이 넘어온다.
//			log.debug("upFile#name={}",upFile.getOriginalFilename()); // 실제 파일명
//			log.debug("upFile#size={}",upFile.getSize()); // 153088
			
			// 1. 서버 컴퓨터 저장
			if(!upFile.isEmpty()) {
				String saveDirectory = application.getRealPath("/resources/upload/board");
				String renamedFilename = HelloSpringUtils.getRenamedFilename(upFile.getOriginalFilename());
				File destFile = new File(saveDirectory, renamedFilename);
				upFile.transferTo(destFile); // 해당 경로에 파일을 저장
				
				// 2. db저장을 위해 Attachment객체 생성
				Attachment attach = new Attachment(upFile.getOriginalFilename(), renamedFilename);
				board.add(attach);
				
			}
			log.debug("board={}",board);
			
			// db에 저장
			int result = boardService.insertBoard(board);
			
			redirectAttr.addFlashAttribute("msg","게시글을 성공적으로 저장");
			
		}
		
		return "redirect:/board/boardList.do";
	}
	
```



**HelloSpringUtils(파일 이름을 새로 지정해 주는 메소드)**

```java
public static String getRenamedFilename(String originalFilename) {
		// 확장자 추출
		int beginIndex = originalFilename.lastIndexOf(".");
		String ext = "";
		if(beginIndex > -1)
			ext = originalFilename.substring(beginIndex); // .txt
		
		// 새이름 생성
		SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMdd_HHmmssSSS_");
		DecimalFormat df = new DecimalFormat("000");
		
		return sdf.format(new Date()) + df.format(Math.random() * 1000) + ext;
	}
```



**ServiceImpl**

```java
@Override
	public int insertBoard(Board board) {
		// insert board
		// 현재 발급된 pk board no 가져오기 작업을 명시적으로 생략할 수 있다 -> 마이바티스의 기능을 통해(boardDao @SelectKey 설정)
		int result = boardDao.insertBoard(board);
		log.debug("board#no={}",board.getNo());
		
		
		// insert Attachment * n
		List<Attachment> attachments = board.getAttachments();
		if(!attachments.isEmpty()) {
			for(Attachment attach : attachments) {
				attach.setBoardNo(board.getNo());
				result = boardDao.insertAttachment(attach);
			}
		}
		return result;
	}
```



**BoardDao**

```java
@Insert("insert into board values(seq_board_no.nextval,#{title},#{memberId},#                   {content},default,default,default)")
@SelectKey(statement = "select seq_board_no.currval from dual", before=false, keyProperty = "no", resultType = int.class)
int insertBoard(Board board);
```









#### 트랜잭션

{: .notice--info}

jdbc, mybatis에서 각각 Connection객체, SqlSession객체에 대해서 commit/rollback을 했던 것과 달리 spring에서는 트랜잭션 관리자가 처리.



###### 트랜잭션 처리

1. Programmatic Transaction : `@Transaction` 어노테이션
2. Declarative Transaction : 선언적 트랜잭션(xml에 선언)



###### 트랜잭션 전파

{: .notice--info}

트랜잭션을 시작하거나 기존 트랜잭션에 참여하는 방법을 결정하는 속성



트랜잭션 전파 속성

1. REQUIRED : 디폴트 속성, 모든 프랜잭션 매니저가 지원하며, 미리 시작된 트랜잭션이 있으면 참여하고 없으면 새로 시작한다.
2. SUPPORTS : 이미 시작된 트랜잭션이 있으면 참여하고 그렇지 않으면 트랜잭션 없이 진행하게 만든다. 트랜잭션이 없긴 하지만 해당 경계 안에서 Connection이나 하이버네이트 Session등을 공유할 수 있다.
3. MANDATORY : REQUIRED와 비슷하게 이미 시작된 트랜잭션이 있으면 참여. 반면에 트랜잭션이 시작된 것이 없으면 새로 시작하는 대신에 예외를 발생시킨다. 혼자서는 독립적으로 사용하면 안 되는 경우에 사용
4. REQUIRED_NEW : 항상 새로운 트랜잭션을 시작. 이미 진행 중인 트랜잭션이 있으면 트랜잭션을 잠시 보류시킨다.
5. NOT_SUPPORTED : 트랜잭션을 사용하지 않게 한다. 이미 진행중인 트랜잭션이 있으면 보류
6. NEVER : 트랜잭션을 사용하지 않도록 강제한다.
7. NESTED : 이미 진행중인 트랜잭션이 있으면 중첩 트랜잭션을 시작한다.



###### 트랜잭션 격리 수준

1. DEFAULT : 사용하는 데이터 엑세스 기술 또는 DB 드라이버의 디폴트 설정을 따른다.
2. READ_UNCOMMITED : 가장 낮은 격리 수준이다. 하나의 트랜잭션이 커밋되기 전에 그 변화가 다른 트랜잭션에 그대로 노출되는 문제가 있다. 하지만 가장 빠르기 때문에 데이터의 일관성이 조금 떨어지더라도 성능을 극대화 할 수 있다.
3. READ_COMMITED : 실제로 가장 많이 사용하는 트랜잭션. 다른 트랜잭션이 커밋하지 않은 정보는 읽을 수 없다.
4. SERIALIZABLE : 가장 강력한 격리수준. 트랜잭션을 순차적으로 진행시켜 주기 때문에 동시에 여러 트랜잭션이 같은 테이블의 정보를 엑세스 하지 못한다.



#### collection

1:1 관계 : association

1:n 관계 : collection



board의 정보들과 memberId를 통해 name을 얻기 위해 member테이블 조인, 게시글의 첨부파일을 가져오기 위해 attachment 조인

```java
<select id="selectOneBoardCollection" resultMap="boardMap">
	select
	    b.*,
	    m.*,
	    a.no attach_no,
	    a.board_no,
	    a.original_filename,
	    a.renamed_filename,
	    a.download_count,
	    a.created_at
	from
	    board b 
	        left join member m
	            on b.member_id = m.member_id
	        left outer join attachment a
	            on b.no = a.board_no
	where
	    b.no = #{no}
 	</select>
 	
 	<!-- borad 기준으로 생각 association, collection 사용 시 매핑 관계를 생략할 수 없다. -->
 	<resultMap type="board" id="boardMap">
 			<id column="no" property="no"/>
 			<result column="title" property="title"/>
 			<result column="member_id" property="memberId"/>
 			<result column="content" property="content"/>
 			<result column="read_count" property="readCount"/>
 			<result column="created_at" property="createdAt"/>
 			<result column="updated_at" property="updatedAt"/>
 			
 			<!-- 1:1관계, property는 getter,setter사용, 보드에 member가 없기때문에 board dto에 멤버 객체 생성 해주어야 한다. -->
 			<association property="member" javaType="member">
 				<id column="member_id" property="memberId"/>
 				<result column="name" property="name"/>
 			</association>
 			
 			<!-- 1:n관계 -->
 			<collection property="attachments" ofType="attachment">
 				<id column="attach_no" property="no"/>
 				<result column="board_no" property="boardNo"/>
 				<result column="original_filename" property="originalFilename"/>
 				<result column="renamed_filename" property="renamedFilename"/>
 				<result column="download_count" property="downloadCount"/>
 				<result column="created_at" property="createdAt"/>
 			</collection>
 	</resultMap>
```





#### 파일 다운로드

###### Resource(org.springframework.core.io.Resource)로 처리할 수 있는 것들

- 웹상 자원 : UrlResource
- classpath 자원 : ClassPathResource
- 서버 컴퓨터 자원 : FileSystemResource
- ServletContext(web root) 자원 : ServletContext Resource
- 입출력 자원 : InputStreamResource
- 이진 데이터 자원 : ByteArrayResource



###### @ResponseBody

핸들러의 반환된 자바 객체를 응답 메세지 바디에 직접 출력하는 경우



###### 흐름

**Controller**

```java
@GetMapping(path="/fileDownload.do", produces = MediaType.APPLICATION_OCTET_STREAM_VALUE)  // 이렇게 해놓은면 이진데이터인지 알 수 있다.
	@ResponseBody
	public Resource fileDownload(@RequestParam int no, HttpServletResponse response) throws IOException {
		// 첨부 파일 정보 가져오기
        Attachment attach = boardService.selectOneAttachment(no);
		log.debug("attach",attach);
		
		String saveDirectory = application.getRealPath("/resources/upload/board");
		File downFile = new File(saveDirectory, attach.getRenamedFilename());
		String location = "file:" + downFile; // File#toString은 파일의 절대 경로 반환
		Resource resource = resourceLoader.getResource(location);
		
		// 응답 헤더 작성
		String filename = new String(attach.getOriginalFilename().getBytes("utf-8"), "iso-8859-1"); // 인코딩 처리
		response.addHeader(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\""+filename+"\"");
		
		return resource;
	}
```





#### 비동기 처리



##### ajax

{: .notice--info}

ajax란 서버와 통신하기 위해 XMLHttpRequest 객체를 사용하는 것, json,xml,html과 같은 다양한 포맷을 주고 받을 수 있다.



###### ajax 통신 방법

1. jsonView 빈을 통해 ajax 응답하기

   - model에 담긴 속성을 json 문자열로 반환해서 응답 메세지 body에 출력한다.
   - BeanNameViewResolver를 통해서 viewName에 해당하는 빈을 찾는다.

   ```java
   @GetMapping("/checkIdDuplicate.do")
   public String checkIdDuplicate1(@RequestParam String memberId, Model model) {
   		Member member = memberService.selectOneMember(memberId);
   		boolean available = member == null;
   		
   		// 사용자에게 전달할 데이터를 모델의 속성으로 전달
   		model.addAttribute("memeberId",memberId);
   		model.addAttribute("available",available);
   		
   		return "jsonView";
   	}
   ```

2. MessageConverter에 의해서 리턴객체를 json으로 변환

   - @ResponseBody(핸들러의 리턴객체를 응답 메세지에 작성)

     ```java
     @GetMapping("/checkIdDuplicate.do")
     @ResponseBody
     public Map<String, Object> checkIdDuplicate2(@RequestParam String memberId) {
     		Member member = memberService.selectOneMember(memberId);
     		boolean available = member == null;
     		
     		Map<String, Object> map = new HashMap<>();
     		map.put("memberId", memberId);
     		map.put("available", available);
     		
     		return map;
     	}
     
     ```

3.  ResponseEntity를 통해

```java
$.ajax({
			url : "${pageContext.request.contextPath}/member/checkIdDuplicate.do",
			data : {memberId}, // 변수명과 속성명이 같다면 memberId : memberId -> memberId로 작성 가능
			success(response){
				//console.log(response); // js object

				const {available} = response;
				
				if(available){
					error.style.display = "none";
					ok.style.display = "inline";
					idValid.value = "1";
				}else{
					error.style.display = "inline";
					ok.style.display = "none";
					idValid.value = "0";
				}
			},
			error(jqxhr, statusText, err){
				console.log(jqxhr, statusText, err);
			}
		})
	})
```



**controller**

```java
/**
	 * ResponseEntity
	 *  - @ResponseBody 기능을 가지고 있다
	 *  - 핸들러에서 응답코드, 응답헤더, 메세지바디를 자유롭게 제어할 수 있도록 도와주는 객체
	 *  - 메세지 바디에 작성할 자바객체는 messageConverter빈에 의해 json으로 처리된다.
	 * 
	 */
	@GetMapping("/checkIdDuplicate.do")
	public ResponseEntity<?> checkIdDuplicate3(@RequestParam String memberId) {
		Member member = memberService.selectOneMember(memberId);
		boolean available = member == null;
		
		Map<String, Object> map = new HashMap<>();
		map.put("memberId", memberId);
		map.put("available", available);
		
		return ResponseEntity.status(HttpStatus.OK).body(map);
	}
```





#### Rest API

{: .notice--info}

웹의 장점을 최대한 활용할 수 있는 아키텍쳐로서 REST를 소개하였고 이는 HTTP 프로토콜을 의도에 맞게 디자인하도록 유도하고 있다. 



##### 구성요소

1. uri : 자원을 표현함
   - 동사보다는 명사를 사용할 것
   - 계층구조로 표현
   - 파일 확장자는 생략
2. method : 기본 crud는 메소드로 표현
   - POST : Create
   - GET : Read
   - PUT : Update
   - DELETE : Delete



##### 특징

- Uniform(유니폼 인터페이스)
  - uri로 지정한 리소스에 대한 조작을 통일되고 한정적인 인터페이스로 수행하는 아키텍쳐 스타일
- Stateless(무상태성)
  - 작업을 위한 상태정보를 따로 저장하지 않는다.(들어오는 요청만을 처리)
  - 그렇기에 서비스의 자유도가 높아지고 서버에 불필요한 정보를 관리하지 않음으로써 구현이 단순
- Cacheable(캐시 가능)
  - http 기존 웹 표준을 그대로 사용하기 때문에 웹에서 사용하는 기존 인프라를 그대로 활용
  - http 프로토콜 표준에서 사용하는 Last-Modified 태그나 E-Tag를 이용하면 캐싱 구현이 가능
- Self-descriptiveness(자체 표현 구조)
  - Rest API 메세지만 보고도 쉽게 이해할 수 있는 구조
- Client-Server 구조
  - 각각의 역할이 확실히 구분되기 때문에 클라이언트와 서버에서 개발해야 할 내용이 명확해지고 서로간 의존성이 줄어든다.
- 계층형 구조
  - 다증 계층으로 구성될 수 있으며,  보안, 로드밸런싱, 암호화 계층을 추가해 구조상의 유연성을 줄 수 있고 Proxy, 게이트웨이 같은 네트워크 기반 중간매체를 사용할 수 있음.



##### Rest 작성시 유의 사항

1. uri는 정보의 자원을 표현해야 한다.
   - 리소스 명은 동사보다 명사
   - /로 계층 표현
   - uri 마지막은 /를 사용하지 않음
   - 파일확장자는 사용하지 않음 - Accept header를 이용해서 파일종 표현
   - _ 대신 -를 사용함
2. 자원에 대한 행위는 http method(get,post,put,delete)로 표현



##### @PathVariable

아래 코드처럼 url에 변수를 넣어 /lang/c | /lang/java와 같이 요청에 따라 리턴값 다르게 할 수 있다.

```java
@GetMapping("/lang/{lang}")
	public ResponseEntity<?> dev(@PathVariable String lang){
        
    }
```



##### @ResponseBody

###### 정의

vo 객체를 json으로 바꿔서 http body에 담는 스프링 어노테이션

@ResponseBody를 생략하고 싶다면 클래스 레벨에 @RestController를 사용하면 자동으로 리턴 값에 @ResponseBody를 붙여준다.





##### @ResponseEntity

###### 정의

- @ResponseBody 기능을 가지고있다.
- 핸들러에서 응답 코드, 응답헤더, 메세지 바디를 자유롭게 제어할 수 있도록 도와주는 객체
- 메세지 바디에 작성할 자바객체는 messeageConverter 빈에 의해 json으로 처리된다.



#### Builder pattern

##### 정의

- GoF의 디자인 패턴 - 생성패턴
- 필드가 여러 개일 경우, 필드값을 개별적으로 등록 후 객체를 생성하는 방법



##### 코드

###### 수동 처리

**dto**

```java
package com.kh.spring.builder.pattern;

import java.time.LocalDate;
/**
 * Builder Pattern
 * -GoF의 디자인패턴 - 생성패턴
 * - 필드가 여러개일 경우, 필드값을 개별적으로 등록 후 객체를 생성하는 방법
 *
 */
public class User {
	private long code; // PK
	private String username; // 유저아이디
	private String password;
	private String name;
	private LocalDate birthday;
	private String phone;
	private boolean married;
	
	public User() {
		super();
		// TODO Auto-generated constructor stub
	}

	public User(long code, String username, String password, String name, LocalDate birthday, String phone,
			boolean married) {
		super();
		this.code = code;
		this.username = username;
		this.password = password;
		this.name = name;
		this.birthday = birthday;
		this.phone = phone;
		this.married = married;
	}
	public static class Builder {
		private long code; // PK
		private String username; // 유저아이디
		private String password;
		private String name;
		private LocalDate birthday;
		private String phone;
		private boolean married;
		
		public Builder code(long code) {
			this.code = code;
			return this; // Builder객체 자신을 반환
		}
		
		public Builder username(String username) {
			this.username = username;
			return this; 
		}
		public Builder password(String password) {
			this.password = password;
			return this; 
		}
		public Builder name(String name) {
			this.name = name;
			return this; 
		}
		public Builder birthday(LocalDate birthday) {
			this.birthday = birthday;
			return this; 
		}
		public Builder phone(String phone) {
			this.phone = phone;
			return this; 
		}
		public Builder married(boolean married) {
			this.married = married;
			return this; 
		}
		
		public User build() {
			return new User(code, username, password, name, birthday, phone, married);
		}
	}
	public static Builder builder() {
		return new Builder();
	}

	@Override
	public String toString() {
		return "User [code=" + code + ", username=" + username + ", password=" + password + ", name=" + name
				+ ", birthday=" + birthday + ", phone=" + phone + ", married=" + married + "]";
	}
}

```



**main**

```java
public class UserMain {
public static void main(String[] args) {
		User u1 = User.builder() // User.Builder객체 
				.code(1L)
				.username("honggd")
				.password("1234")
				.name("홍길동")
				.birthday(LocalDate.of(1999, 9, 9))
				.phone("01012341234")
				.married(false)
				.build(); // User객체
		
		
		System.out.println(u1); // User [code=1, username=honggd, password=1234, name=홍길동, birthday=1999-09-09, phone=01012341234, married=false]
	}
}
```



###### @builder

```java
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Client {
	private long code; // PK
	private String username; // 유저아이디
	private String password;
	private String name;
	private LocalDate birthday;
	private String phone;
	private boolean married;
}
```





#### Spring Security



##### 개념

Spring Security는 스프링 기반의 어플리케이션 보안을 담당하는 프레임워크.

사용자 인증, 권한, 보안처리를 간단하고 강력하게 구현 가능

Filter 기반으로 동작하기 때문에 Spring MVC와 분리되어 동작한다.

- 인증(Authentication) 접근한 유저를 식별하고, 애플리케이션에 접근할 수 있는지 검사하는 것
  - 접근 주체(Principal) 보안 시스템이 작동되고 있는 애플리케이션에 접근하는 유저
  - Credentials : 특정 리소스에 접근하려는 사용자가 인증을 제공하기 위해 사용하는 비밀번호
- 인가(Authorization) 인증된 유저가 애플리케이션의 기능을 이용할 수 있는 지 검사하는 것.
  - 권한(Authorities) 인증된 유저가 가진 권한 목록



##### Spring Security Filter Chain

@web.xml

1. DelegatingFilterProxyRegistrationBean이 DelegatingFilterProxy 필터 클래스를 `springSecurityFilterChain` 이라는 이름의 Filter로 등록

   - legacy project에서는 web.xml에서 DelegatingFilterProxy필터 등록시 application-context빈으로 등록됨.

2. Servler이전 FilterChain실행중, `springSecurityFilterChain`에 도달하면, `DelegatingFilterProxy`클래스는 `FilterChainProxy` 클래스에게 처리를 위임.

   - `FilterChainProxy`는 `AuthenticationFilter` 들을 리스트로 보관하고 있는 클래스

   - `FilterChainProxy`의 `AuthenticationFilter`들을 순서대로 실행.

     ```java
     <filter>
     		<filter-name>springSecurityFilterChain</filter-name>
     		<filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>
     	</filter>
     	<filter-mapping>
     		<filter-name>springSecurityFilterChain</filter-name>
     		<url-pattern>
     	</filter-mapping>
     ```

3. <a href="https://docs.spring.io/spring-security/site/docs/3.0.x/reference/security-filter-chain.html">Filter Chain 상세 설명</a>

4. <a href="https://atin.tistory.com/590">필터체인 이해하기</a>



##### Authentication

###### 과정

1. 요청으로 부터 username과 password 추출
2. username과 password로 Authentication의 구현체인 UsernamePasswordAuthenticationToken 생성
   - UsernamePasswordAuthenticationToken의 principal에는 사용자의 id, credential에는 password 대입
3. AuthenticationManager<\<interface>>의 구현체인 ProviderManager에게 인증을 위임
   - AuthenticationManager : Authentication 객체를 받아 인증하고 인증이 완료된 객체를 돌려주는 메소드를 구현하도록 하는 인터페이스
   - ProviderManager : AuthenticationManager의 구현체. 멤버변수로 존재하는 AuthenticationProvider 들에게 인증을 위임하고, 인증 요청을 처리할 수 있는 AuthenticationProvider가 인증에 성공하면 인증이 완료를 알려준다.
   - 인증을 처리할 수 있는지 여부는 AuthenticationProviders의 support메서드에 의해 결정된다.
4. UserDetails 인터페이스를 구현한 사용자 vo클래스, UserDetailsService 인터페이스를 구현한 서비스 클래스를 필요로 한다.



##### security 설정

###### legacy project

1. pom.xml에 security 프레임워크 의존 추가

   ```java
   <dependency>
       <groupId>org.springframework.security</groupId>
       <artifactId>spring-security-core</artifactId>
       <version>${org.springframework.security-version}</version>   
   </dependency>
   <dependency>
       <groupId>org.springframework.security</groupId>
       <artifactId>spring-security-web</artifactId>
       <version>${org.springframework.security-version}</version>   
   </dependency>
   <dependency>
       <groupId>org.springframework.security</groupId>
       <artifactId>spring-security-config</artifactId>
       <version>${org.springframework.security-version}</version>     
   </dependency>
   <dependency>
       <groupId>org.springframework.security</groupId>
       <artifactId>spring-security-taglibs</artifactId>
       <version>${org.springframework.security-version}</version>     
   </dependency>
   <dependency>
       <groupId>org.springframework.security</groupId>
       <artifactId>spring-security-test</artifactId>
       <version>${org.springframework.security-version}</version>     
   </dependency>        
   ```

2. spring-security는 springSecurityFilterChain빈을 참조하므로 application-context에서만 작동한다.

   ```java
   // web.xml에 security filter chain 등록
   <filter>
       <filter-name>springSecurityFilterChain</filter-name>
       <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>
   </filter>
   <filter-mapping>
       <filter-name>springSecurityFilterChain</filter-name>
       <url-pattern> /* </url-pattern>
   </filter-mapping>
   ```

3. filter 등록 후에는 spring-security.xml에 http, authentication-manager태그를 작성 후 테스트 가능( DelegatingFilterProxy 필터태그만 주석하면, security관련기능을 모두 끌수 있다.)

   ```java
   <authentication-manager>
   		<authentication-provider user-service-ref="memberSecurityService">
   			<!-- db에 저장해서 불러오는 것이 아닌 수동적으로 작성하여 로그인 기능 체크 -->
   			<!-- <user-service>
   				<user name="honggd" password="$2a$10$/ikh9hhdGhNJ8NDRPENRRuKiLEVpR7sy/dXqviYP7HNh63CI8kYSO" authorities="ROLE_USER"/>
   				<user name="admin" password="$2a$10$/ikh9hhdGhNJ8NDRPENRRuKiLEVpR7sy/dXqviYP7HNh63CI8kYSO" authorities="ROLE_USER, ROLE_ADMIN"/>
   			</user-service> -->
   			
   			<password-encoder ref="bcryptPasswordEncoder"/>
   		</authentication-provider>
   	</authentication-manager>
   	
   	<!-- @Service클래스를 빈으로 등록 -->
   	<context:component-scan base-package="com.kh.security" />
   ```

4. application-context에 security-context.xml 파일 추가(`/WEB-INF/spring/*-context.xml` 와일드카드를 활용해, 두 설정파일을 한번에 등록가능)

   ```java
   // web.xml
   <context-param>
   		<param-name>contextConfigLocation</param-name>
   		<param-value>
   		/WEB-INF/spring/*-context.xml
   		</param-value>
   	</context-param>
   ```

5. security-context.xml에 인증권한 관련 설정들 해주기

   ```java
   <!-- #7.1 암호화 처리 빈 등록 -->
   	<beans:bean id="bcryptPasswordEncoder" class="org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder"/>
   	
   	<!-- #7.3 인증/권한 관련 설정 -->
   	<http security="none" pattern="/resources/**"/>
   	<!-- intercept-url은 구체적->일반적인 설정순으로 작성 -->
   	<http auto-config="true">
   		<intercept-url pattern="/" access="permitAll()"/>
   		<intercept-url pattern="/index.jsp" access="permitAll()"/>
   		<intercept-url pattern="/member/member.do" access="isAnonymous()"/>
   		<intercept-url pattern="/member/memberLogin.do" access="isAnonymous()"/>
   		<!-- logout같은 경우는 seesion이 만료되었을 경우에 logout하는 경우도 되야하기 때문에 permitAll()로 처리 -->
   		<intercept-url pattern="/member/memberLogout.do" access="permitAll()"/>
   		<intercept-url pattern="/admin/**" access="hasRole('ADMIN')"/>
   		
   		<intercept-url pattern="/**" access="isAuthenticated()"/>
   		
   		<!-- 
   			login-page : 로그인 폼 요청. 작성필요
   			login-processing-url : security 로그인 처리. 작성 불필요
   			username-parameter : 기본값 username
   			password-parameter : 기본값 password
   			default-target-url : 로그인 성공후 리다이렉트 url, 기본값 root	
   			always-use-default-target : 항상 루트로 리다이렉트 false(이전 요청 페이지로 리다이렉트)	
   		 -->
   		<form-login 
   			login-page="/member/memberLogin.do"
   			login-processing-url="/member/memberLogin.do"
   			default-target-url="/"
   			always-use-default-target="false"
   			username-parameter="memberId"
   			password-parameter="password"
   			authentication-success-forward-url="/member/memberLoginSucess.do"
   			/>
   			
   		<logout
   			logout-url="/member/memberLogout.do"
   			logout-success-url="/"
   		/>
   		
   		<!-- 
   			Cross-site Request Forgery 공격대비 설정
   			- 사용자의 특정 권한을 이용하여 공격자의 의도된 행동을 실행하게 만드는 공격법
   			- 특정 사용자의 권한 수정, 등록/수정/삭제
   			- 모든 post 요청에 spring이 제공하는 token값 검증
   		 -->
   		<csrf disabled="false"/>	
   	</http>
   ```

6. SimpleGrantedAuthority 별칭 등록하기

   ```java
   // mybatis-config.xml
   
   <typeAliases>
     	<typeAlias type="org.springframework.security.core.authority.SimpleGrantedAuthority" alias="simpleGrantedAuthority"/>
     	<package name="com.kh.spring"/>
     </typeAliases>
   ```

   



###### springboot

`WebSecirutyConfigureAdapter` WebSecirutyConfigure 를 쉽게 생성할 수 있도록 제공되는 추상 클래스

```
MvcMatchersAuthorizedUrl org.springframework.security.config.annotation.web.configurers.ExpressionUrlAuthorizationConfigurer.ExpressionInterceptUrlRegistry.mvcMatchers(HttpMethod method, String... mvcPatterns)
```

`mvcMatchers` 를 활용하면 요청 method별로 권한 검사를 실시할 수 있다.



```java
@Override
protected void configure(HttpSecurity http) throws Exception {
	http.authorizeRequests()
	    .mvcMatchers(HttpMethod.GET, "/", "/member/login", "/member/join").permitAll()
	    .mvcMatchers(HttpMethod.POST, "/member/login", "/member/join").permitAll()
	    .antMatchers("/member/detail").hasRole("ROLE_USER")             
	    .anyRequest().authenticated();
}
```



@config.WebSecurityConfig

```java
@Configuration
@EnableWebSecurity
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {

	@Autowired
	private MemberService memberService;
	
	@Autowired
	private DataSource dataSource;

	@Bean
	public PersistentTokenRepository tokenRepository() {
		JdbcTokenRepositoryImpl tokenRepository = new JdbcTokenRepositoryImpl();
		tokenRepository.setDataSource(dataSource);
		return tokenRepository;
	}

	
	/**
	 * 클래스레벨에 작성한 @Configuration 하위에서 작동. 
	 * 리턴 객체를 빈으로 등록하는 사용.
	 * id : passwordEncoder 메소드 이름
	 */
	@Bean
	public PasswordEncoder passwordEncoder() {
		return new BCryptPasswordEncoder();
	}
	
	/**
	 * WebSecurity객체를 통해 인증대상에서 제외될 자원을 설정
	 */
	@Override
	public void configure(WebSecurity web) throws Exception {
		web.ignoring().antMatchers("/resources/**");
	}

	/**
	 * HttpSecurity객체를 통해 인증/권한, 로그인/로그아웃등을 설정
	 */
	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http.authorizeRequests()
			.antMatchers("/member/**").authenticated()
			.antMatchers("/board/**").hasRole(MemberService.ROLE_USER)
			.antMatchers("/admin/**").hasRole(MemberService.ROLE_ADMIN)
			.antMatchers("/").permitAll();
		
		http.formLogin()
			.loginPage("/member/memberLogin.do")	// GET /login
			.loginProcessingUrl("/member/memberLogin.do") // POST /login
			.usernameParameter("id")
			.passwordParameter("password")
			.defaultSuccessUrl("/")
			.permitAll();
		
		//remember-me 기능 : session timeout이상으로 인증을 유지
		http.rememberMe()
			.key("spring-security-app") // application별 고유문자열
			.tokenValiditySeconds(60 * 60 * 24 * 14) // 14일 기본값
			.tokenRepository(tokenRepository()); // database관련정보 제공
		
		http.logout()
			.logoutUrl("/member/memberLogout.do") // POST
			.logoutSuccessUrl("/")
			.invalidateHttpSession(true);
		
		//접근권한 없음 페이지 연결
		http.exceptionHandling()
			.accessDeniedPage("/error/accessDenied.do");
		
	}

	/**
	 * AuthenticationManagerBuilder객체를 통해
	 * UserDetailsService구현체 빈, 비밀번호 암호화 빈 등록
	 */
	@Override
	protected void configure(AuthenticationManagerBuilder auth) throws Exception {
		auth.userDetailsService(memberService)
			.passwordEncoder(passwordEncoder());
		
	}
	
}
```





##### Security Member 흐름

###### Member 

아래 세개의 메소드들의 리턴값을 enabled로 처리해주어야 한다.

```java
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@ToString(callSuper = true)
public class Member extends MemberEntity implements UserDetails {

	/**
	 * SimpleGrantedAuthority
	 *  - 문자열로 권한을 관리
	 *  - "ROLE_USER" -> new SimpleGrantedAuthority("ROLE_USER")
	 */
	private List<SimpleGrantedAuthority> authorities;
	
	@Override
	public Collection<? extends GrantedAuthority> getAuthorities() {
		// TODO Auto-generated method stub
		return authorities;
	}

	@Override
	public String getUsername() {
		// TODO Auto-generated method stub
		return memberId;
	}

	@Override
	public boolean isAccountNonExpired() {
		// TODO Auto-generated method stub
		return enabled;
	}

	@Override
	public boolean isAccountNonLocked() {
		// TODO Auto-generated method stub
		return enabled;
	}

	@Override
	public boolean isCredentialsNonExpired() {
		// TODO Auto-generated method stub
		return enabled;
	}

}
```





###### 로그인 후처리 Controller

```java
@PostMapping("/memberLoginSucess.do")
	public String memberLoginSucess(HttpSession session) {
		log.debug("/memberLoginSucess.do 호출!");
		// 로그인 후처리
		String location = "/";
		
		// security가 관리하는 다음 리다이렉트 url
		SavedRequest savedRequest = (SavedRequest)session.getAttribute("SPRING_SECURITY_SAVED_REQUEST");
		if(savedRequest != null) {
			location = savedRequest.getRedirectUrl();
		}
		log.debug("location={}",location);
		return "redirect:" + location;
	}
```



###### authentication을 받아 회원 정보 받아오기

```java
@GetMapping("/memberDetail.do")
	public ModelAndView memberDetail(Authentication authentication, ModelAndView mav) {
		Object principal = authentication.getPrincipal();
		Object credentials = authentication.getCredentials();
		Collection<? extends GrantedAuthority> authorities = authentication.getAuthorities();
		log.debug("principal={}",principal);
		log.debug("credentials={}",credentials);
		log.debug("authorities={}",authorities);
		
		mav.setViewName("member/memberDetail");
		return mav;
	}
```



##### MemberSecurityService

UserDetailsService 인터페이스 implements한다.

```java
@Service
@Slf4j
public class MemberSecurityService implements UserDetailsService {

	@Autowired
	MemberSecurityDao memberSecurityDao;
	
	/**
	 * username으로 해당 회원 조회(member,authority)
	 * - 조회한 회원이 없는 경우 UsernameNotFoundException 예외 던지기
	 */
	@Override
	public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
		Member member = memberSecurityDao.loadUserByUsername(username);
		if(member == null)
			throw new UsernameNotFoundException(username);
		
		log.info("member={}",member);
		return member;
	}

}
```



##### security-mapper

member 와 authority 테이블은 1:n 관계, 서브쿼리로 처리

```java
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
    
<mapper namespace="com.kh.security.model.dao.MemberSecurityDao">
    
 	<select id="loadUserByUsername" resultMap="memberAuthMap">
 		select
 			*
 		from
 			member
 		where
 			member_id = #{username}
 	</select>
 	
 	<resultMap type="member" id="memberAuthMap">
 		<id column="member_id" property="memberId"/>
 		<collection property="authorities" // Member 클래스의 Setauthorities를 의미
 					javaType="arrayList" 
 					column="member_id" // 조회할 때 사용할 컬럼 지정
 					ofType="simpleGrantedAuthority" // 리스트의 하나의 요소 타입 작성(여기서 authorities 리스트의 요소 하나 타입이 simpleGrantedAuthority이다.)
 					select="selectAuthorities"/> // 이 쿼리를 실행
 	</resultMap>
 	
    // selectAuthorities를 호출하는 것은 위의 collection 태그 안에 서 호출.
    
 	<select id="selectAuthorities" resultMap="simpleGrantedAuthorityMap">
 		select
 			*
		from
			authority
		where
			member_id = #{memberId}
 	</select>
 	
    // SimpleGrantedAuthority를 자바 객체로 변환하려면 생성자 방식을 이용해야 하기 때문에 아래 처럼 사용
 	<resultMap type="simpleGrantedAuthority" id="simpleGrantedAuthorityMap">
		 <constructor>
		 	<arg column="auth" javaType="string"/>
		 </constructor>
 	</resultMap>
</mapper>
```



##### UserDetails

security 인증에 사용될 vo클래스는 UserDetails 인터페이스를 직접 구현하거나, User를 상속해 Adapter Pattern으로 처리할 수 있다.



##### 사용자 정보 가져오기

1. Controller(Authentication을 통해 가져오기)

   ```java
   @GetMapping("/memberDetail.do")
   	public ModelAndView memberDetail(Authentication authentication, ModelAndView mav) {
   		Object principal = authentication.getPrincipal();
   		Object credentials = authentication.getCredentials();
   		Collection<? extends GrantedAuthority> authorities = authentication.getAuthorities();
   		log.debug("principal={}",principal);
   		log.debug("credentials={}",credentials);
   		log.debug("authorities={}",authorities);
   		
   		mav.setViewName("member/memberDetail");
   		return mav;
   	}
   ```

2. jsp

   - principal.속성 으로 꺼내오기

   - `Member loginMember = (Member)SecurityContextHolder.getContext().getAuthentication().getPrincipal();`을 통해 loginMember에 담아서 꺼내기

   ```java
   <form:form name="memberUpdateFrm" action="${pageContext.request.contextPath}/member/memberUpdate.do" method="post">
   		<!-- principal객체에서 값 꺼내오기 -->
   		<input type="text" class="form-control" placeholder="아이디 (4글자이상)" name="memberId" id="memberId" value='<sec:authentication property="principal.memberId"/>' readonly required/>
   		<input type="text" class="form-control" placeholder="이름" name="name" id="name" value='<sec:authentication property="principal.name"/>' required/>
   		<input type="date" class="form-control" placeholder="생일" name="birthday" id="birthday" value='<sec:authentication property="principal.birthday"/>'/>
   		<input type="email" class="form-control" placeholder="이메일" name="email" id="email" value='<sec:authentication property="principal.email"/>' required/>
   		<input type="tel" class="form-control" placeholder="전화번호 (예:01012345678)" name="phone" id="phone" maxlength="11" value='<sec:authentication property="principal.phone"/>' required/>
   		<input type="text" class="form-control" placeholder="주소" name="address" id="address" value='<sec:authentication property="principal.address"/>'/>
   		
   		<!-- principal을 loginMember로 변수처리하여 사용할 수 있게 해준다 -->
   		<sec:authentication property="principal" var="loginMember"/>
   		
   		<select class="form-control" name="gender" required>
   		  <option value="" disabled selected>성별</option>
   		  <option value="M" value="${loginMember.gender eq 'M' ? 'selected' : ''}">남</option>
   		  <option value="F" value="${loginMember.gender eq 'F' ? 'selected' : ''}">여</option>
   		</select>
   		
   		<%
   			// Member loginMember = (Member) pageContext.getAttribute("loginMember"); 해도 가져온다 위에서 설정한 설정 때문에
   			
   			Member loginMember = (Member)SecurityContextHolder.getContext().getAuthentication().getPrincipal();
   			String[] hobby = loginMember.getHobby();
   			List<String> hobbyList = hobby != null ? Arrays.asList(hobby) : null;
   			pageContext.setAttribute("hobbyList", hobbyList);
   		%>
   		
   		<div class="form-check-inline form-check">
   			취미 : &nbsp; 
   			<input type="checkbox" class="form-check-input" name="hobby" id="hobby0" value="운동" ${hobbyList.contains('운동') ? 'checked' : '' }>
   			<label for="hobby0" class="form-check-label" >운동</label>&nbsp;
   			<input type="checkbox" class="form-check-input" name="hobby" id="hobby1" value="등산" ${hobbyList.contains('등산') ? 'checked' : '' }>
   			<label for="hobby1" class="form-check-label" >등산</label>&nbsp;
   			<input type="checkbox" class="form-check-input" name="hobby" id="hobby2" value="독서" ${hobbyList.contains('독서') ? 'checked' : '' }>
   			<label for="hobby2" class="form-check-label" >독서</label>&nbsp;
   			<input type="checkbox" class="form-check-input" name="hobby" id="hobby3" value="게임" ${hobbyList.contains('게임') ? 'checked' : '' }>
   			<label for="hobby3" class="form-check-label" >게임</label>&nbsp;
   			<input type="checkbox" class="form-check-input" name="hobby" id="hobby4" value="여행" ${hobbyList.contains('여행') ? 'checked' : '' }>
   			<label for="hobby4" class="form-check-label" >여행</label>&nbsp;
   		</div>
   ```

   

##### jsp : security-taglibs



##### 인증객체 수정

1. Controller

   ```java
   @PostMapping("/memberUpdate.do")
   	public String memberUpdate(@ModelAttribute Member member, RedirectAttributes redirectAttr, Model model) {
   		// 1. db row 갱신
   		int result = memberService.updateMember(member);
   		
   		UserDetails updatedMember = memberSecurityService.loadUserByUsername(member.getMemberId());
   		
   		// 2. authentication 객체 수정
   		// 새로 Authentication을 만드는 방법
   		Authentication newAuthentication = new UsernamePasswordAuthenticationToken(updatedMember, 				updatedMember.getPassword(),updatedMember.getAuthorities());
           
   		SecurityContextHolder.getContext().setAuthentication(newAuthentication);
   		
   		redirectAttr.addFlashAttribute("msg","회원정보를 성공적으로 등록하였습니다.");
   		return "redirect:/member/memberDetail.do";
   	}
   ```

   

##### remember me

1. security-context.xml에 설정

   ```java
   	<!--  remember me 설정 token-validity-seconds : 유효기간 초단위. 60 * 60 * 24 * 14 => 일주일-->
           <http>
   	 		<remember-me data-source-ref="dataSource" token-validity-seconds="1209600"/>
           </http>
   ```

2. jsp

   ```java
   <div>
       <input type="checkbox" name="remember-me" id="remember-me" class="form-check-input" />
       <label for="remember-me" class="form-check-label">로그인 유지</label>
   </div>
   ```

   

##### 커스텀 에러 페이지

1. security-context.xml에 접근제한 걸기

   ```java
   <http>
   	<!-- custon error page -->
       <access-denied-handler error-page="/error/accessDenied.do"/>
   </http>
   ```

2. ErrorController

   ```java
   @Controller
   @Slf4j
   public class ErrorController {
   	@GetMapping("/error/accessDenied.do")
   	public void accessDenied() {}	
   }
   ```

3. accessDenied.jsp

   ```java
   <%@ page language="java" contentType="text/html; charset=UTF-8"
       pageEncoding="UTF-8"%>
   <!DOCTYPE html>
   <html>
   <head>
   <meta charset="UTF-8">
   <title>오류</title>
   </head>
   <body style="text-align:center">
   	<h1>접근 권한이 없는 페이지 입니다.</h1>
   	<a href="${pageContext.request.contextPath}/">홈으로</a>
   </body>
   </html>
   ```

   

#### Spring boot(3.0.0 버전부터는 jdk17로 사용하기 11로 했더니 버전 안맞는다고 오류남)

spring-legacy는 root-context.xml, servlet-context에서 관리하는데 spring boot는 하나의 파일에서 빈 관리



##### 생성

spring.io 홈페이지 -> project(Spring boot) -> Quick Stater -> 원하는 설정 입력해주고 다운



##### 설정

1. pom.xml에 sprnig-boot에서 jsp를 사용하기 위한 의존 추가

   ```java
   <!-- #1 springboot에서 jsp 사용을 위한 의존 -->
   		 <dependency>
               <groupId>javax.servlet</groupId>
               <artifactId>jstl</artifactId>
           </dependency>
           <dependency>
               <groupId>org.apache.tomcat.embed</groupId>
               <artifactId>tomcat-embed-jasper</artifactId>
               <scope>provided</scope>
           </dependency>
   ```

2. src/main/webapp/WEB-INF/views 폴더 만들어서 jsp 파일 위치시키기(index.jsp는 webapp하위에)

3. application.properties 파일 설정

   ```xml
   server.port=10000
   server.servlet.context-path=/springboot
   
   # datasource
   spring.datasource.driver-class-name=oracle.jdbc.OracleDriver
   spring.datasource.url=jdbc:oracle:thin:@localhost:1521:xe
   spring.datasource.username=spring
   spring.datasource.password=spring
   
   
   # mybatis
   mybatis.configuration.jdbc-type-for-null=NULL
   mybatis.configuration.map-underscore-to-camel-case=true
   mybatis.type-aliases-package=com.kh.spring.menu
   # mybatis.mapper-locations=classpath#:mapper/**/*-mapper.xml
   
   
   # logback
   logging.level.com.kh.spring = debug
   ```



##### REST API(GET)

**Controller**

```java
@GetMapping("/type/{type}/taste/{taste}")
	public ResponseEntity<?> findByTypeTaste(@PathVariable Type type, @PathVariable Taste taste){
		// dao에 값을 넘길 때는 하나로 합쳐서 넘겨주는 것이 좋다.
		Menu menu = Menu.builder().type(type).taste(taste).build();
		
		List<Menu> list = menuService.findByTypeTaste(menu);
		if(list.isEmpty())
			return ResponseEntity.notFound().build();
		
		return ResponseEntity.ok(list);
	}
```

**jsp**

```java

// div안에 비동기 처리로 가져온 값들 뿌려주는 이벤트
<script>
const renderTable = (response, id) => {
		const container = document.querySelector(id);
		let html = `
		<table class='table'>
			<thead>
				<tr>
					<th>번호</th>
					<th>음식점</th>
					<th>메뉴명</th>
					<th>가격</th>
					<th>타입</th>
					<th>맛</th>
				</tr>
			</thead>
			<tbody>
		`;
		if(response.length){
			response.forEach((menu) => {
				const {id, restaurant, name, price, type, taste} = menu;
				html += `
					<tr>
						<td>\${id}</td>
						<td>\${restaurant}</td>
						<td>\${name}</td>
						<td>￦\${price.toLocaleString()}</td>
						<td> 
							<span class="badge badge-pill badge-\${type === 'kr' ? 'primary' : (type === 'jp' ? 'secondary' : 'warning')}">\${type}</span>
						</td>
						<td>
							<span class="badge badge-pill badge-\${taste === 'mild' ? 'info' : 'danger'}">\${taste}</span>
						</td>
					</tr>
				`;
			});
		}
		else {
			html += `
				<tr>
					<td class='text-center' colspan="6">검색된 결과가 없습니다.</td>
				</tr>
			`;			
		}
		html += `
			</tbody>
		</table>
		`;
		
		container.innerHTML = html;
	};    
</script>

<div class="menu-test">
        <h4>메뉴 타입/맛별 조회(GET)</h4>
        <form name="menuTypeTasteFrm">
            <div class="form-check form-check-inline">
                <input type="radio" class="form-check-input" name="type" id="get-kr" value="kr">
                <label for="get-kr" class="form-check-label">한식</label>&nbsp;
                <input type="radio" class="form-check-input" name="type" id="get-ch" value="ch">
                <label for="get-ch" class="form-check-label">중식</label>&nbsp;
                <input type="radio" class="form-check-input" name="type" id="get-jp" value="jp">
                <label for="get-jp" class="form-check-label">일식</label>&nbsp;
            </div>
            <br />
            <div class="form-check form-check-inline">
                <input type="radio" class="form-check-input" name="taste" id="get-hot" value="hot">
                <label for="get-hot" class="form-check-label">매운맛</label>&nbsp;
                <input type="radio" class="form-check-input" name="taste" id="get-mild" value="mild">
                <label for="get-mild" class="form-check-label">순한맛</label>
            </div>
            <br />
            <input type="submit" class="btn btn-block btn-outline-success btn-send" value="전송" >
        </form>
    </div>
    <div class="result" id="menuTypeTaste-result"></div>
    <script>
    	document.menuTypeTasteFrm.addEventListener('submit',(e)=>{
    		e.preventDefault();
    		$.ajax({
    			url : `${pageContext.request.contextPath}/menu/type/\{type}/taste/\{taste}`,
    			success(response){
    				console.log(response);
    				renderTable(response,"#menuTypeTaste-result");
    			},
    			error(xhr, satsusText,err){
    				if(xhr.status == 404){
    					alert("해당 맛/타입의 메뉴가 존재하지 않습니다.");
    				}else{
    					console.log
    				}
    			}
    			
    		})
    	})
    </script>
```



##### REST API(POST)









json.stringify?



client -> spring페이지 -> springboot ㅠ페이지

오류 해결

Access to XMLHttpRequest at 'http://localhost:10000/springboot/menu' from origin 'http://localhost:9090' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.









