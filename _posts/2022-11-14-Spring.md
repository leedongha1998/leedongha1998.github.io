---
title: "Spring 공부"
categories:
 - Spring
tags: [Spring] 
toc: true
author_profile: true #profile sidebar 감추기
# sidebar:
#     nav: "docs" # 목차 사이드바
search: true #검색 피하기
---

[toc]



#### Mybatis

###### Mybatis란?

{: .notice--info}

데이터의 CRUD를 보다 편하게 사용하기 위해 xml로 구조화된 Mapper 설정 파일을 통해서 JDBC를 구현한 영속성 프레임워크이다.

###### Mybatis 흐름

Controller => Service => DAO => Mybatis설정파일 => DB

![image-20221121214503723](C:\Users\eedon\AppData\Roaming\Typora\typora-user-images\image-20221121214503723.png)

###### Mybatis 동작 구조

Session Factory Builder가 mybatis-config.xml 참조(class의 alias설정, db 연결 설정, sql 구문 경로 설정 등)하여 session factory 생성

----->  Session Factory 가 session 생성 

-----> Session이 mapper.xml 참조(sql 구문 설정(인자값, 결과값, 데이터 타입 등))

-----> (selectOne, selectList, selectMap, insert, delete, update 실행)                                            



###### Mybatis-config 설정하기

1. src/mybatis 폴더를 생성하고, mybatis-config.xml 파일 등록

2. mybatis-config.xml 작성 (mybatis 사이트에서 형식 보고 알맞게 사용)

    <a href="https://mybatis.org/mybatis-3/ko/index.html">마이바티스</a>

3. mapper 파일 생성 및 설정(쿼리 실행이 필요한 model의 위치에 mapper 폴더를 생성하고 식별하기 쉬운 이름으로 파일 등록)



###### mapper 태그

1. resultMap 태그 : 조회한 결과를 객체와 Row간의 1:1 매칭이 아닌, 원하는 객체의 필드에 담아 반환하고자 할 때 사용한다.

   ```java
   <resultMap id="resultMember" type="Member">
       <!-- prop은 필드명, column은 db 컬럼명-->
       <id property="id" column="ID"/>
       <result property="passwd" column="PASSWD"/>
   </resultMap>
   ```

2. select 태그 : sql의 조회 구문을 작성할 때 쓰인다. 해당 쿼리를 외부에서 접근하고자 할 때 namespace.ID명을 적어 접근이 가능하다

   - select 태그의 주요 속성
     - id : 구문을 찾기 위해 사용될 수 있는 네임 스페이스 내 유일한 구분자
     - parameterType : 구문에 전달될 파라미터의 클래스명(패키지 경로 포함)이나 별칭
     - resultType : 리턴되는 타입의 패키지 경로를 포함한 전체 클래스명이나 별칭. collection인 경우, list, arrayList로 설정할 수 있다.
     - resultMap : 사용할 resultMap의 id를 기술한다.

   ```java
   <select id="memberInfo" parameterType="string" resultType="_int"/>
      select * from member where id = #{userid}
   </select>
   ```



###### Mybatis SqlSessionFactory 생성

- Mybatis-config.xml, mapper.xml 파일 생성을 완료했다면, DAO에서 세션 생성을 위한 getSqlSessoinFactory() 메소드를 작성한다.

  ```java
  private SqlSessionFactory getSqlSessoin(){
      
      String resource = "mybatis/mybatis-config.xml";
      SqlSessionFactory factory = null;
      try{
          // mybatis-config.xml의 설정 정보를 inputStream 객체를 통해 읽어와 SqlSessionFactory 객체를 생성한다.
          InputStream inputStream = Resources.getResourceAsStream(resource);
          SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();
          factory = builder.build(inputStream);
      }catch(IOException e){
  
      }
      return factory;
  }
  ```



###### Mybatis SqlSession 생성

- Dao 메소드는 SqlSessionFactory를 사용하여 SqlSession 객체를 생성한다.

  ```java
  public Member selectMember(Member m){
      Member member = null;
      SqlSession session = null;
      
      try{
          // getSqlSessionFactory() 메소드를 통해 세션 정보를 받아와 SqlSession을 생성한다.
          session = getSqlSessionFactory().openSession(false);
          
          // 매퍼 파일 안에 작성된 쿼리문 실행시키고 결과를 받는다.
          member = session.selectOne("Member.loginCheck", m);
          System.out.println(session);
      }catch(Exception e){
          e.printStackTrace();
      }finally{
          session.close();
      }
      return member;
  }
  ```



###### Mybatis 동적 쿼리

{: .notice--info}

일반적으로 검색 기능이나 다중 입력 처리 등을 수행해야 할 경우 sql을 실행하는 dao를 여러 번 호출하거나 batch 기능을 이용하여 버퍼에 담아서 한번에 실행 시키는 방식으로 쿼리를 구현했다면, **마이바티스에서는 이를 동적으로 제어할 수 있는 구문을 제공하여 더 쉽게 쿼리를 구현 할 수 있다.**



###### 지원 구문 종류

1. if 

   ```java
   <select id="searchBoard" resultType="arraylist">
       select * from board
       where writer = 'admin'
       <if test="title != null">
           and title like #{title}
   	</if>
   </select>
   ```

2. choose(when, otherwise) : 주어진 구문 중 한 가지만을 수행하고자 할 때 사용.

   ```java
   <choose>
       <when test="조건식">
       	...
       </when>
       <when test="조건식">
       	...
       </when>
       <otherwise>
       	...
       </otherwise>
   </choose>
   ```

3. trim(where, set)

   - <trim> : 쿼리의 구문의 특정 부분을 없앨 때 사용. 
   - <where> : 기존 쿼리의 where 절을 동적으로 구현할 때 사용.  시작하는 and 나 or 을 제거해준다. where 태그 내부의 if 문이 모두 false 인 경우 where 키워드를 제거해준다.
   - <set> : 기존의 update set 절을 동적으로 구현할 때 사용. 쿼리 실행 시 set을 붙이고 마지막에 끝나는 문장의 ,를 제거한다.

4. foreach

   - 동적 쿼리를 구현할 때 collection에 대한 반복 처리를 제공.

   - foreach태그의 속성

     - item : 반복 될 때 접근 가능한 각 객체 변수

     - index : 반복되는 횟수를 가리키는 변수

     - collection : 반복에 쓰일 Collection 객체

     - open : 첫 반복 시 포함할 여는 문자열 ex) ' ( '

     - close : 마지막 반복 시 포함할 닫는 문자열 ex) ' ) '

     - separator : 반복되는 객체를 나열할 때 사용할 구분자 ex)  ' , '

       ```java
       <select id="searchBadwords" resultType="arraylist">
           select * from board
           where title in
           <foreach item="item" index="index" collection="list" open="(" separator="," close=")">
           	#{item}
       	</foreach>
       </select>
       ```

       



if,when의 test 속성에는 && || < > <= >= 연산자 사용 불가 -> and, or, lt, gt, le, ge 사용할 것



#### Log4j



###### log4j의 레벨들

- fatal : 아주 심각한 에러
- error : 처리 도중 오류(예외) 발생
- warn : 현재 프로그램 실행에는 문제되지는 않지만, 향후 시스템의 잠재적 오류가 될 수 있는 경우
- info : 프로그램 실행 중에 상태변경과 같은 메세지
- debug : 개발 도중 필요한 메세지
- trace : 흐름의 시작과 끝을 정의하는 용도



###### log4j 사용법

<a href="https://cluster-taek.tistory.com/entry/log4j%EC%9D%98-%EA%B0%9C%EB%85%90%EA%B3%BC-%EC%82%AC%EC%9A%A9%EB%B2%95">참고 사이트</a>

```java
// 로그 수집 주체
<logger name = "com.kh.app">
    <level value ="info"/>
</logger>
```



#### MAVEN



###### MAVEN이란?

자바용 프로젝트 관리 도구, (POM) XML 문서를 통해 해당 프로젝트의 버전 정보 및 라이브러리 정보들을 통합하여 관리하는 프레임워크.

지역 저장소에 저장해준다 (C -> 사용자 -> .m2 디렉토리에 저장됨)



###### POM 이란?

{: .notice--info}

POM(Project Object Model)은 하나의 프로젝트에서 사용하는 자바 버전, 라이브러리, 플러그인 구성을 통합하여 관리할 수 있게 각 설정 정보를 xml 문서화 한 것을 말한다.



pom.xml에 의존 등록

```java
<dependencies>

	<dependency>

		여기 위치에 메이븐 사이트에서 의존 붙여넣기

	</dependency>

</dependencies>
```



###### Maven target 폴더

Maven을 사용할 경우 프로젝트 컴파일 시 target/classess 안에 컴파일 된 클래스 파일들이 위치하게 된다.

일반적으로 maven clean 옵션을 사용하면 제거되어 문제는 없지만, 이후 형상관리를 위해 프로젝트를 공유할 시 컴파일 된 결과까지 공유할 필요는 없기 때문에 target 폴더를 공유 목록에서 제외하는 ignore 작업을 설정하자.



###### replection api

jdk의 기본 기능 중 하나. 

- 클래스 객체를 통해서 클래스 정보 열람.

- 객체를 생성.

- 메소드를 호출. 

- 필드 값 제어 처리.



클래스 객체

- 클래스 당 하나 씩 만들어지는 객체로 클래스의 모든 정보를 가지고 있다.
- new 연산자 호출시에도 이 클래스 객체를 베이스로 객체가 생성된다.



**객체 생성**

```java
// 기존 객체 생성
Sample s1 = new Sample();

// 클래스 객체 생성
Class clz1 = Sample.class;
Class clz2 = s1.getClass();
Class clz3 = Class.forName("com.kh.app.reflection.api.Sample"); // 예외 처리해줘야 함.

System.out.print(clz1 == clz2); // true
System.out.print(clz1 == clz3); // true

// 기본 생성자
Constructor<Sample> const1 = clz1.getDeclaredConstructor(null);
Sample s2 = const1.newInstance(null);

//파라미터 생성자
Class[] parameterTypes = {int.class, String.class};
Constructor<Sample> const2 = clz1.getDeclaredConstructor(parmeterTypes);
Object[] initArgs = {100, "helloworld"};
Sample s3 = const2.newInstance(initArgs);
```



###### 메소드 제어

```java
Class<Sample> clz = Sample.class;
Method[] methods = clz.getDeclaredMethods();
for(Method method : methods){
    System.out.println(method);
}

// 하나의 메소드 가져오기
Sample sample = clz.getDeclaredConstructor(null).newInstance(null);

//setNum 메소드 가져오기
Method setNum = clz.getDeclaredMethod("setNum",int.class);
setNum.invoke(sample, 123);

// getNum 메소드 가져오기
Method getNum = clz.getDeclaredMethod("getNum",null);
Object returnValue = getNum.invoke(sample);

System.out.print(returnValue); // 123
System.out.print(sample); // 123
```



###### 필드 제어

```java
Class<Sample> clz =(Class<Sample>)Class.forName("com.kh.app.reflection.api.Sample");

Sample sample = clz.getDeclaredConstructor(int.class, String.class).newInstance(123,"wow");
Field num = clz.getDeclaredField("num");
System.out.println(num); // 필드 정보도 tostring 처리 되어 보여진다.

num.setAccessible(true); // private필드도 접근 가능하게 해준다.

Object value = num.get(sample);
System.out.println(value);

System.out.println(sample); // Sample[num = 123, str = Wow]

```



#### Lombok

###### Lombok 설치

(버전이 안맞아서 적용 안될 수 있으니 주의!)

1. maven repository 에서 lombok 의존 복사
2. pom.xml에 붙여넣기
3. pom.xml에 표시된 lombok 설치된 경로에 가서 jar파일을 복사해서 eclipse 실행 파일에 붙여넣기
4. 해당 경로에서 cmd 열고 java -jar lombo-(버전).jar 실행
5. Specify location 선택 후 eclipse.exe 선택 후 install
6. eclipse 파일 안에 eclipse.ini 마지막 줄에 롬복 설치 문장 추가된 것 확인하기



###### lombok 활용

보통 클래스 레벨에 @Getter, @Setter 등등 어노테이션을 통하여 관리 가능. -> eclipse outline에서 확인 가능

- @Getter
- @Setter
- @NoArgsConstructor
- @AllArgsConstructor
- @ToString
- @Log4j
- @RequiredArgsConstructor : 꼭 필요한 인자만 받는 생성자.



#### Framework

###### Framework란?

{: .notice--info}

소프트웨어를 개발함에 있어 코드를 구현하는 개발 시간을 줄이고, 코드의 재사용성을 증가시키기 위해 일련의 클래스 묶음이나 뼈대, 틀을 제공하는 라이브러리를 구현해 놓은 것.



###### Library란?

{: .notice--info}

다른 프로그램들과 링크되기 위해 존재하는 하나 이상의 서브루틴이나 함수들이 저장된 파일의 모음.



###### Framework 특징

1. 개발자가 따라야 하는 가이드를 제공.
2. 개발할 수 있는 범위가 정해져 있다.
3. 개발자를 위한 다양한 도구, 플러그인 지원



###### Framework 종류

1. 영속성 : 데이터 저장, 조회, 변경, 삭제를 다룸 ex) Mybatis, Hibernate
2. 자바 : Java EE를 통한 웹 어플리케이션 개발에 초점을 맞춤 ex) Spring
3. 화면 구현 : Front-End를 보다 쉽게 구현 ex) Bootstrap, Foundation, react js, vue js
4. 기능 및 지원 : 특정 기능이나 업무 수행에 도움을 줌 ex) Log4j, JUnit 5, ANT



#### Spring Framework



###### Spring 모듈(모듈 : 프로그램을 구성하는 구성 요소로, 관련된 데이터와 함수를 하나로 묶은 단위 의미)

1. spring-beans : 스프링 컨테이너를 이용해서 객체를 생성하는 기본 기능을 제공
2. spring-context : 객체생성, 라이프 사이클 처리, 스키마 확장등의 기능 제공
3. spring-aop : aop 기능 제공
4. spring-web : REST 클라이언트 데이터 변환 처리, 서블릿 필터, 파일 업로드 지원 등 웹 개발에 필요한 기반 기능을 제공
5. spring-webmvc : 스프링 기반의 mvc 프레임워크, 웹 어플리케이션을 개발하는데 필요한 컨트롤러, 뷰 구현을 제공
6. spring-websocket : 스프링 mvc에서 웹 소켓 연동을 처리할 수 있도록 한다.
7. spring-oxm : xml과 자바 객체간의 매핑 처리를 위한 api 제공
8. spring-tx : 트랜잭션 처리를 위한 추상 레이어 제공
9. spring-jdbc : jdbc 프로그래밍을 보다 쉽게 할 수 있는 템플릿 제공
10. spring-orm : 하이버네이트, JPA, Mybatis 등과의 연동을 지원
11. spring-jms : jms 서버와 메세지를 주고 받을 수 있도록 하기 위한 템플릿
12. spring-context-support : 스케쥴링, 메일발송, 캐시연동, 벨로시티 등 부가 기능을 제공



###### Spring MVC 동작 구조

Request -> DispatcherServlet(web.xml) -> HandlerMapping(servlet-context.xml) -> Controller(Controller->Service -> Dao -> db -> Dao -> Service -> Controller) -> DispatcherServlet -> ViewResolver -> view -> Response



1. 클라이언트가 Request요청을 하면 DispatcherServlet이 요청을 가로챈다.(이때 DispatcherServlet이 모든 요청을 가로채는 것이 아닌 web.xml에 <url-patter>에 등록된 내용만 가로챈다.)
2. DispatcherServlet이 가로챈 요청을 HandlerMapping에 보내 해당 요청을 처리할 Controller를 찾는다.
3. 실제 로직 처리
4. 로직 처리 후, DispatcherServlet에 view 이름을 리턴
5. ViewResolver를 통해 결과를 출력할 view 화면을 검색한다.
6. 처리 결과를 view에 송신하고, view 화면을 최종 클라이언트에게 전송



###### 구성 요소

- DispatcherServlet : 클라이언트의 요청을 받음, 요청에 맞는 컨트롤러가 리턴한 결과값을 view에 전달하여 알맞은 응답을 생성.
- HandlerMapping : 클라이언트의 요청 URL을 어떤 컨트롤러가 처리할 지 결정
- Controller : 클라이언트의 요청을 처리한 뒤, 결과를 DispatcherServlet에게 리턴
- ModelAndView : 컨트롤러가 처리한 결과 정보 및 뷰 선택에 필요한 정보를 담는다
- ViewResolver : 컨트롤러의 처리 결과를 생성할 view를 결정
- view : 컨트롤러의 처리 결과 화면을 생성, jsp나 velocity 템플릿 파일 등을 view 로 사용



###### spring 프로젝트 구조

- java 폴더 : 우리가 작성하는 .java 파일의 위치
- resources 폴더: 프로젝트 설정에 필요한 xml 등의 설정파일들
- webapp 폴더 : 사용자 화면에 표시할 view 관련 파일들과 웹 컨테이너 설정에 필요한 xml 파일들
  - webapp폴더 하위의 resources 폴더 : 웹 상에서 사용될 css, js파일을 저장
  - webapp폴더 하위의 classes 폴더 : src에서 작성한 .java 파일을 컴파일하여 만든 .class파일을 저장한다.
  - webapp폴더 하위의 spring 폴더 : spring의 설정 xml 문서들 저장
  - webapp폴더 하위의 views 폴더 : html, jsp 등 사용자 화면에 보여질 웹 문서를 저장한다.
  - web.xml 파일 : 웹 서버에서 사용할 기본 설정 기록





#### Spring IOC

###### IoC 컨테이너

- 스프링에서 관리하는 객체를 Bean이라고 하고, 해당 빈들을 관리한다는 의미로 컨테이너를 Bean Factory 라고 한다.
- <span style="color:red">역할</span> 
  - 객체의 생명주기와 의존성을 관리.
  - VO(DTO/POJO) 객체의 생성, 초기화, 소멸 등의 처리를 관리.
  - 개발자가 직접 객체를 생성할 수 있지만, 해당 권한을 컨테이너에 맡김으로써 소스 코드 구현의 시간 단축을 할 수 있다.



###### IoC 컨테이너와 Bean객체

- Bean 
  - 스프링이 IoC 방식으로 관리하는 Class
  - <span style="color:red">스프링이 직접 생성과 제어를 담당</span>하는 객체
- Bean Factory
  - 스프링의 IoC를 담당하는 핵심 컨테이너
  - <span style="color:red">Bean을 등록,생성,조회,반환</span>하는 기능을 담당
- Application Context
  - BeanFactory를 확장한 IoC 컨테이너
  - Bean을 등록하고 관리하는 기능은 빈팩토리와 동일하지만 스프링이 제공하는 각종 부가 서비스를 추가로 제공
- 설정 메타정보
  - ApplicationContext 또는 BeanFactory가 IoC를 적용하기 위해 사용하는 설정 정보
  - 설정 메타정보는 IoC컨테이너에 의해 관리되는 bean객체를 생성하고 구성할 때 사용



###### Spring DI

- 장점
  - 코드 단순화
  - 객체 간의 종속 관계 해소
- DI의 종류
  - Setter 주입
  - 생성자 의존 주입
  - 필드 주입



###### Spring DI XML

- XML 구조

  - <beans>태그를 최상위로 태그하여 <beans>태그안에 다양한 태그로 값을 설정 가능

- 주요 태그

  - <beans> : xml 파일의 최상위 태그, 여러가지 namespace(p,c,aop,context,tx,mvc 등)를 설정

  - <bean> : 스프링에서 사용할 POJO객체를 컨테이너에 등록하여 컨테이너가 사용할 수 있게 만드는 태그

    - 기본 속성값

      - id="String" : 객체 생성시 사용하는 변수(명명규칙은 카멜케이스 사용)
      - name="String" : 자바 식별자 작성규칙을 따르지 않는다, 특수기호 포함시 사용
      - class="클래스명" : POJO 객체를 지정. 패키지를 포함한 클래스명 작성 ex)com.kh.spring.클래스명

      

    - 기타 속성

      - init-method="메소드명" : 객체 생성 후 초기화 하거나 실행되어야 할 기능이 있는 경우
      - destroy-method="메소드명" : 객체 삭제되기 전에 실행되어야 할 기능이 있는 경우
      - lazy-init="true|false" : 객체가 즉시 로딩되지 않고 사용시 로딩(true)
      - scope="설정값" : 객체 생성 방식을 지정

      

    - <bean>태그 안에 사용가능한 태그들

      - <constructor-arg> : <bean>지정된 객체가 생성될 때 기본생성자가 아닌 매개변수가 있는 생성자로 생성하여 초기값을 대입(일치하는 파라미터 생성자가 있어야 함)
      - <property> : <bean>으로 지정된 객체의 멤버에 값 대입

  - <import> : 설정 파일을 불러오는 태그



###### Spring DI 관리

1. xml 단독 사용

   - 모든 빈을 명시적으로 xml에 등록하는 방법
     - 장점 : 모든 빈을 xml에서 확인 가능, 관리의 편의성이 높다
     - 단점 : 빈 개수가 많아지면 xml 파일을 관리하기 어렵다, 협업시에 설정파일에 충돌 가능, DI에 필요한 적절한 setter메소드 | 생성자가 코드 내부에 반드시 있어야 한다.

2. xml과 어노테이션의 혼용

   - 빈으로 사용될 클래스에 어노테이션을 부여

     - 장점 : 개발 속도 향상, 협업시 설정 파일 충돌 최소화
     - 단점 : 의존관계를 한 눈에 파악하기 어려움

   - 어노테이션 종류

     - @Component : 객체를 나타내는 타입

     - @Repository : 영속성을 가지는 속성(파일, 데이터베이스)을 가진 크래스

     - @Service

     - @Controller

     - @Autowired : 의존관계를 설정한 객체로부터 의존 관계를 자동으로 주입

     - @Qualifier : @Autowired와 함께 쓰며, @Autowired로 DI하고자 하는 객체가 여러개 일 경우 에러가 나기에 @Qualifier("name")을 통해 원하는 객체를 지정하여 주입

       







#### spring legacy project

공부하는 버젼은 sts3 버전이다. -> spring legacy 가능하다 4도 가능하나 플러그인에서 가끔 문제 생길 때가 있다고 한다.

springreload를 사용하기 위해서 jdk 8 버전으로 사용



###### spring legacy project 만들기

1. new -> spring-legacy project 선택
2. templates칸에서 spring mvc project  선택
3. 패키지 작성하는 칸에 3레벨 이상 쓰고 ex) com.kh.spring -> spring이 context-path이다.



###### 초기 설정

1. window -> preferences 에서 인코딩 설정
2. installed JREs java-1.8 설정, compiler 1.8로 변경
3. server runtime 설정에서 tomcat 9.0 버전으로 변경



###### 스프링의 특징

1. 제어의 반전(IoC)
   - 컨트롤의 제어권이 개발자가 아니라 프레임워크에 있다.
   - 객체의 생성부터 모든 생명주기의 관리까지 객체의 제어권이 바뀜
   - 객체를 생성하고, 직접 호출하는 자바프로그램이 아니라, 만들어둔 자원을 프레임워크에서 호출해서 사용
2. 의존성 주입(DI)
   - 객체간의 의존관계를 관리하는 기술
   - 어떤 객체가 필요로 하는 객체를 자기 자신이 직접 생성하는 것이 아니라, 외부에 있는 다른 곳에서 자신이 필요로 하는 객체를 주입 받는 것
3. POJO(Plain)
   - 일반적인 j2ee 프레임워크에 비해 특정 라이브러리를 사용할 필요가 없어서 개발이 쉬우며, 기존 라이브러리 지원이 용이함
4. PSA
   - 스프링은 다른 여러 모듈을 사용함에 있어서 별도의 추상화 레이어 제공 
   - 예를 들어 JPA를 사용할 때에서 Spring JPA를 사용하여 추상화 하므로 실제 구현에 있어서 Hibernate를 사용하든 EclipseLink를 사용하든 사용자는 이 모듈의 의존 없이 프로그램에 집중가능.
5. 관점지향프로그래밍, AOP
   - 트랜잭션, 로깅, 보안 등 여러 모듈, 여러 계층에서 적용되는데, 이런 코드들을 실제 비지니스 로직과 분리
   - 한때, AOP가 OOP(Object Oriented Programming)를 대체하는 기술로 생각되기도 했지만, 실제로 AOP는 OOP를 더욱 OOP스럽게 보완해 주는 기술임.



###### context(bean-manager)

1. xml
2. java annotaion -> @Configuration
3. xml + annotation



###### src/main/webapp 과 src/main/resources

src/main/webapp -> static 파일들 ex) .java .css

src/main/resources -> buildpath



#### spring의 xml파일들

root-context

- mvc 설정과 관련된 여러 처리를 담당하는 설정 파일로 DAO, VO 그리고 Service 등과 같은 파일을 어떻게 사용할 것인가 빈(객체)들을 관리하는 문서
- 빈은 servlet-context에 의해서 참조할 수 없다. 하지만 반대의 경우는 가능하다.
- ex) datasource 빈 등록, mybatis,SqlSessionFactoryBean, SqlSessionTemplate 빈등록, SqlSession 인터페이스 구현체 빈 등록, @Mapper 인터페이스 등록

servlet-context 

- MVC Model의 View와 관련된 객체를 정의한다.
- url과 관련된 Controller, @(Annotation),ViewResolver 등의 설정, Front-End의 설정 파일 느낌이다.

web.xml

- Tomcat과 같은 WAS(Web Application Server)가 최초로 구동될 때, 각종 설정을 정의해주는 파일이다. root-context.xml, servlet-context.xml 같은 설정 파일을 어디서 가져올 것인지 설정해주는 설정을 위한 설정 파일이라고 할 수 있다.

pom.xml

- maven project 생성 시 모듈을 다운받기 위한 xml



#### mybatis-config.xml

```java
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
  PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
  <!-- 
  	자식태그는 다음 순서로 작성할 것!
  	properties?, settings?, typeAliases?, typeHandlers?, objectFactory?, objectWrapperFactory?, 
 	reflectorFactory?, plugins?, environments?, databaseIdProvider?, mappers?
   -->  
  <settings>
  	<setting name="jdbcTypeForNull" value="NULL"/><!-- null데이터 전달시 그대로 null로 대입 -->
  	<setting name="mapUnderscoreToCamelCase" value="true"/>
  </settings>
  
  <typeAliases>
  	<package name="com.kh.spring"/>
  </typeAliases>
  
  <!-- 타입핸들러에 String[]->varchar 위한 설정을 여기에 적어준다. -->
  <typeHandlers>
  	<!-- <typeHandler handler="com.kh.spring.common.typehandler.StringArrayTypeHandler"/> -->
  	<package name="com.kh.spring.common.typehandler"/>
  </typeHandlers>
</configuration>
```



#### Spring 설정

1. 자바 버전 최신화(java1.8, spring5.2.22 release, servlet 4.0.1, jsp 2.3.1)

   ```java
   <properties>
   		<java-version>1.8</java-version>
   		<org.springframework-version>5.2.22.RELEASE</org.springframework-version>
   		<org.aspectj-version>1.6.10</org.aspectj-version>
   		<org.slf4j-version>1.6.6</org.slf4j-version>
   </properties>
       
   <!-- #1.2 serlvet/jsp -->
   		<dependency>
   			<groupId>javax.servlet</groupId>
   			<artifactId>javax.servlet-api</artifactId>
   			<version>4.0.1</version>
   			<scope>provided</scope>
   		</dependency>
   		<dependency>
   			<groupId>javax.servlet.jsp</groupId>
   			<artifactId>javax.servlet.jsp-api</artifactId>
   			<version>2.3.1</version>
   			<scope>provided</scope>
   		</dependency>
   		<dependency>
   			<groupId>javax.servlet</groupId>
   			<artifactId>jstl</artifactId>
   			<version>1.2</version>
   		</dependency>
   ```

2. servlet 버전과 web.xml 버전을 일치시킨다.

3. root-context 설정파일 위치

   ```java
   <context-param>
   		<param-name>contextConfigLocation</param-name>
   		<param-value>/WEB-INF/spring/root-context.xml</param-value>
   </context-param>
   ```

4. 단 하나의 Servlet, DispatcherServlet 하위에서 빈을 관리하는 servlet-context

   ```java
   <servlet>
   		<servlet-name>appServlet</servlet-name>
   		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
   		<init-param>
   			<param-name>contextConfigLocation</param-name>
   			<param-value>/WEB-INF/spring/appServlet/servlet-context.xml</param-value>
   		</init-param>
   		<load-on-startup>1</load-on-startup>
   </servlet>
   		
   <servlet-mapping>
   		<servlet-name>appServlet</servlet-name>
   		<url-pattern>/</url-pattern>
   </servlet-mapping>
   ```

5. encoding filter

   ```java
   <filter>
   		<filter-name>encodingFilter</filter-name>
   		<filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
   		<init-param>
   			<param-name>encoding</param-name>
   			<param-value>utf-8</param-value>
   		</init-param>
   		<init-param>
   			<param-name>forceEncoding</param-name>
   			<param-value>true</param-value>
   		</init-param>
   </filter>
   <filter-mapping>
   		<filter-name>encodingFilter</filter-name>
   		<url-pattern>/*</url-pattern>
   </filter-mapping>
   ```

6. lombok(맨날 작성하는 것들 대신 작성해주는 친구)

   ```java
   <dependency>
   	        <groupId>org.projectlombok</groupId>
   	        <artifactId>lombok</artifactId>
   	        <version>1.18.24</version>
   	        <scope>provided</scope>
   </dependency>
   ```

7. spring-jdbc, mybatis, dbcp, ojdbc8

   ```java
   <dependency>
               <groupId>org.springframework</groupId>
               <artifactId>spring-jdbc</artifactId>
               <version>${org.springframework-version}</version>
   </dependency>
   <dependency>
               <groupId>org.mybatis</groupId>
               <artifactId>mybatis</artifactId>
               <version>3.4.6</version>
   </dependency>
   <dependency>
               <groupId>org.mybatis</groupId>
               <artifactId>mybatis-spring</artifactId>
               <version>1.3.2</version>
   </dependency>
           <!-- Database Connection Pool -->
   <dependency>
               <groupId>commons-dbcp</groupId>
               <artifactId>commons-dbcp</artifactId>
               <version>1.4</version>
   </dependency>
   <dependency>
               <groupId>com.oracle.database.jdbc</groupId>
               <artifactId>ojdbc8</artifactId>
               <version>21.1.0.0</version>
   </dependency>
   ```

8. datasource 빈 등록(root-context.xml에)

   ```java
   <context:property-placeholder location="classpath:datasource.properties"/>
   	<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
   		<property name="driverClassName" value="${datasource.driverClassName}"></property>
   		<property name="url" value="${datasource.url}"></property>
   		<property name="username" value="${datasource.username}"></property>
   		<property name="password" value="${datasource.password}"></property>
   	</bean>
   ```

9. mybatis, SqlSessionFactoryBean, SqlSessionTemplate 빈 등록

   ```java
   <bean id="sqlSessionFactoryBean" class="org.mybatis.spring.SqlSessionFactoryBean">
   		<!-- 여기에서 name dataSource는 setDataSource를 의미하고 ref의 dataSource는 위에 등록한 빈의 아이디이다. -->
   		<property name="dataSource" ref="dataSource"/>
   		<property name="mapperLocations" value="classpath*:mapper/**/*-mapper.xml"/>
   		<property name="configLocation" value="classpath:mybatis-config.xml"/>
   	</bean>
   	<!-- SqlSession인터페이스 구현체. Dao구현 클래스에 의존주입되어 실행된다. -->
   	<bean id="sqlSessionTemplate" class="org.mybatis.spring.SqlSessionTemplate">
   		<constructor-arg ref="sqlSessionFactoryBean" index="0"/>
   	</bean>
   ```

10. @Mapper 인터페이스 등록 : Dao 구현 객체를 동적으로 생성(root-context.xml)

   ```java
   <mybatis-spring:scan base-package="com.kh.spring.**.dao"/>
   ```

11. web.xml에 security-context.xml 등록

    ```java
    	<context-param>
    		<param-name>contextConfigLocation</param-name>
    		<param-value>
    		/WEB-INF/spring/root-context.xml
    		/WEB-INF/spring/security-context.xml
    		</param-value>
    	</context-param>
    ```

12. 암호화 처리 빈 등록(security-context.xml)

    ```java
    <bean id="bcryptPasswordEncoder" class="org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder"></bean>
    ```

13. spring-security 관련 의존 추가

    ```java
    	<dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-core</artifactId>
            <version>${org.springframework.security-version}</version>     
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-web</artifactId>
            <version>${org.springframework.security-version}</version>     
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-config</artifactId>
            <version>${org.springframework.security-version}</version>     
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-taglibs</artifactId>
            <version>${org.springframework.security-version}</version>     
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <version>${org.springframework.security-version}</version>     
        </dependency>        
    ```

    





#### @Controller 클래스의 핸들러 메소드가 가질 수 있는 매개변수 타입

- HttpServletRequest
- HttpServletResponse
- HttpSession
- java.util.Locale : 요청에 대한 Local
- InputStream/Reader : 요청에 대한 입력 스트림
- OutputStream/Writer : 응답에 대한 출력 스트림



사용자 입력값 처리

- Command 객체 : http요청 파라미터를 커맨드객체에 저장한 VO객체
- CommandMap : HandlerMethodArgumentResolver에 의해 처리된 사용자 입력값을 가진 Map객체
- @Valid : 커맨드 객체 유효성 검사 객체
- Error,BildingResult : Command객체에 저장결과(Command객체 바로 다음 위치시킬 것)
- @PathVariable : 요청 url중 일부를 매개변수로 취할 수 있다.
- @RequestParam : 사용자 입력값을 자바변수에 대입 처리(필수 여부 설정)
- @RequestHeader : 헤더값
- @CookieValue : 쿠키값
- @RequestBody : http message body에 작성된 json을 vo객체로 변환 처리



뷰에 전달할 모델 데이터 설정

- ModelAndView
- ModelMap
- Model
- @ModelAttribute : model속성에 대한 getter
- @SessionAttribute : session속성에 대한 getter(required 여부 선택 가능)
- SessionStatus : @SessionAttributes로 등록된 속성에 대하여 사용완료 처리. 세션을 폐기하지 않고 처리.



기타

- MultipartFile : 업로드파일 처리 인터페이스
- RedirectAttributes : DML 처리 후 요청 주소 변경을 위한 redirect시 속성처리 지원



#### Controller(초기)

```java
@Controller
@RequestMapping("/demo") // requestMapping을 클래스 레벨에 작성하여 중복되는 url처리 해줌.
public class DemoController {
	
	static final Logger log = LoggerFactory.getLogger(DemoController.class);
	
	@Autowired
	private DemoService demoService;
	
	/**
	 * value = path에 대한 별칭
	 * method : 작성하지 않으면 모든 전송방식을 허용 
	 */
	@RequestMapping(path="/devForm.do", method = RequestMethod.GET)
	public String devForm() {
		log.info("{} 요청이 들어왓습니다","/demo/devForm.do");
		return "demo/devForm";
	}
	
	@RequestMapping(path="/dev1.do", method = RequestMethod.POST)
	public String dev1(HttpServletRequest request, HttpServletResponse response) {
		String name = request.getParameter("name");
		int career = Integer.parseInt(request.getParameter("career"));
		String email = request.getParameter("email");
		String _gender = request.getParameter("gender");
		Gender gender = _gender != null ? Gender.valueOf(_gender) : null;
		String[] lang = request.getParameterValues("lang");
		
		Dev dev = new Dev(0, name, career, email, gender, lang, LocalDateTime.now());
		
		log.info("dev = {}",dev);
		
		request.setAttribute("dev", dev);
		
		return "demo/devResult";
	}
	
	/**
	 * 
	 * @RequestParam
	 * - 모든 필드는 필수값(기본값)
	 * - required = false (옵션으로 처리)
	 * - 자바 변수명, name속성값과 일치하는 사용자 입력값을 찾는다.
	 * - 기본값 처리도 가능하다.
	 * -> requestparam은 꼭 받아야 하는 값처리할 때 사용하는 것이 좋다.
	 */
	@RequestMapping(path="/dev2.do", method = RequestMethod.POST)
	public String dev2(
			// view 단 폼에서 name 속성이랑 일치하는 것으로 매칭한다.
			@RequestParam(required=false, defaultValue="홍길동") String nm,
			@RequestParam int career,
			@RequestParam String email,
			@RequestParam(required=false) Gender gender,
			@RequestParam String[] lang,
			Model model
			) {
		
		Dev dev = new Dev(0, nm, career, email, gender, lang, LocalDateTime.now());
		log.info("dev={}",dev);
		
		// view 단에 전달한 데이터를 model에 속성으로 추가 -> request scope에 속성으로 저장
		model.addAttribute("dev",dev);
		
		return "demo/devResult";
	}
	
	/**
	 * 
	 * 커맨드 객체
	 * - 사용자 입력 name값 - property(setter)가 일치하면 값대입
	 * - 자동으로 model속성으로 등록된다.
	 */
	@RequestMapping(path="/dev3.do" , method=RequestMethod.POST)
	public String dev3(Dev dev // 위 메소드 처럼 리퀘스트파람으로 받아오는 방법 대신 dev객체로 받았다) {
		log.info("dev={}",dev);
		
		return "dev/devResult";
	}
	
	@RequestMapping(path="/insertDev.do", method = RequestMethod.POST)
	public String insertDev(Dev dev, RedirectAttributes redirectAttr) {
		int result = demoService.insertDev(dev);
		
		redirectAttr.addFlashAttribute("msg","개발자 등록 성공!");
		return "redirect:/";
	}
	
	@RequestMapping(path="/devList.do", method=RequestMethod.GET)
	public String devList(Model model) {
		List<Dev> list = demoService.selectDevList();
		log.info("list={}",list);
		model.addAttribute("list",list);
		return "demo/devList";
    }
}

```



#### Controller 중기

{: .notice--info}

기존에는 @RequestMapping을 통하여 url매핑을 해줬다면, @Get/@PostMapping을 통하여 메소드 타입에 맞게 설정해줌



###### key point

- @GetMapping, @PostMapping
- model 객체를 통해 session에 저장하려면 클래스 레벨에 @SessionAttributes를 통하여 세션에 저장
  -  @SessionAttributes로 세션관리를 한다면, SessionStatus#setComplete로 만료처리해야 한다.
- @slf4j 를 통해 로그 출력 -> log4j.xml에서 로그레벨 설정
- BCryptPasswordEncoder를 의존 주입 받아서 비밀번호 암호화
- viewName이 null인 경우 요청 url을 기준으로 jsp 위치를 추론한다.

```java
package com.kh.spring.member.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.SessionAttributes;
import org.springframework.web.bind.support.SessionStatus;
import org.springframework.web.servlet.mvc.support.RedirectAttributes;

import com.kh.spring.member.model.dto.Member;
import com.kh.spring.member.model.service.MemberService;

import lombok.extern.slf4j.Slf4j;

@Controller
@RequestMapping("/member")
@Slf4j
@SessionAttributes({"loginMember"})
public class MemberController {

//	static final Logger log = LoggerFactory.getLogger(MemberController.class);
	
	@Autowired
	private MemberService memberService;
	
	@Autowired
	private BCryptPasswordEncoder bcryptPasswordEncoder;
	
	//@RequestMapping(path="/member/memberEnroll.do",method=RequestMethod.GET)
	@GetMapping("/memberEnroll.do")
	public String memberController() {
		return "member/memberEnroll";
	}
	
	/**
	 * $2a$10$2.AdYu08nfVhU89v8PyfsuF0kObCQvGCdJiR3I5p1dSQMY81FfD6O
	 * 
	 * - $2a$ 알고리즘타입
	 * - 10$ 옵션 (비용이 높을수록 속도가 오래걸리고, 메모리사용량이 많다)
	 * - 2.AdYu08nfVhU89v8Pyfsu 22자리 random salt
	 * - F0kObCQvGCdJiR3I5p1dSQMY81FfD6O 31자리 hashing + encoding처리
	 * 
	 */
	@PostMapping("/memberEnroll.do")
	public String memberEnroll(Member member, RedirectAttributes redirectAttr) {
		try {
			log.debug("member = {}", member);
			
			// 비밀번호 암호화
			String rawPassword = member.getPassword();
			String encodedPassword = bcryptPasswordEncoder.encode(rawPassword);
			member.setPassword(encodedPassword);
			log.debug("encodedPassword = {}", encodedPassword);
			
			int result = memberService.insertMember(member);
			redirectAttr.addFlashAttribute("msg", "회원 가입이 정상적으로 처리되었습니다.");
			return "redirect:/";
		} catch(Exception e) {
			log.error("회원등록 오류 : " + e.getMessage(), e);
			throw e;
		}
	}
	/**
	 * viewName이 null인 경우 요청 url을 기준으로 jsp 위치를 추론한다.
	 *  -> member/memberLogin 
	 *
	 */
	@GetMapping("/memberLogin.do")
	public void memberLogin() {
		
	}
	
	@PostMapping("/memberLogin.do")
	public String memberLogin(@RequestParam String memberId,
                              @RequestParam String password,
                              RedirectAttributes redirectAttr,
                              Model model) {
		
		// 1. memberId로 회원 조회
		Member member = memberService.selectOneMember(memberId);
		log.debug("member = {}",member);
		
		String location = "/";
		// 2. member가 null이 아니면서, 비밀번호가 일치하면 로그인
		if(member != null && bcryptPasswordEncoder.matches(password, member.getPassword())) {
			// model을 통해 session scope에 속성 저장 : 클래스 레벨에 @SessionAttributes
			model.addAttribute("loginMember",member);
		}else {
			redirectAttr.addFlashAttribute("msg","회원 정보가 일치하지 않습니다.");
			location = "/member/memberLogin.do";
		}
		return "redirect:" + location;
	}
	
	/**
	 * @SessionAttributes로 세션관리를 한다면, SessionStatus#setComplete로 만료처리해야 한다.
	 * 
	 */
	@GetMapping("/memberLogout.do")
	public String memberLogout(SessionStatus sessionStatus) {
		
		if(!sessionStatus.isComplete())
			sessionStatus.setComplete();
		
		return "redirect:/";
	}
}
```



#### Model

{: .notice--info}

mvc의 model이 아닌 view 단에 데이터를 전달하기 위한 임시 저장소, Map 객체.



- ModelAndView
  - model - addObject
  - view - setView(View) | setViewName(String)
- ModelMap
  - model -addAttribute
  - view 없음. handler에서 view정보를 문자열로 반환해야 함.
- Model
  - model - addAttribute
  - view 없음. handler에서 view 정보를 문자열로 반환해야 함.



###### 관련 어노테이션

- @ModelAttribute

  - 메소드 레벨 -  해당 컨트롤러의 전역 모델 속성 등록

  - 메소드 매개변수에 작성 - 모델 속성에 대한 getter

  - ```java
    // /demo로 시작하는 url 요청이 왔을 때 common이라는 값에 email, tel값 담을 수 있다. 따라서 /demo로 시작하는 view단에 ${common.email}. ${common.tel}을 통해 값 확인 가능
    @ModelAttribute("common")
    	public Model common(Model model) {
    		log.debug("@ModelAttribute - common 호출!");
    		model.addAttribute("email","admin@kh.com");
    		model.addAttribute("tel","010-1233-2222");
    		return model;
    	}
    ```

- @SessionAttribute : 메소드 매개변수에 작성. session scope에 저장된 속성에 대한 getter

- @SessionAttributes : 클래스 레벨, session scope에 저장된 속성명 관리





#### java 타입을 db에 넣기 위한 핸들러(String[] -> varchar)

```java
@MappedTypes(String[].class) // java type 작성
@MappedJdbcTypes(JdbcType.VARCHAR) // jdbc type 작성
// 핸들러 생성할 때 BaseTypeHandler 상속받을 것!!!!
public class StringArrayTypeHandler extends BaseTypeHandler<String[]> {
	/**
	 * String[] -> varchar
	 * - parameter가 null인 경우는 호출되지 않는다.
	 */
	@Override
	public void setNonNullParameter(PreparedStatement ps, int i, String[] parameter, JdbcType jdbcType)
			throws SQLException {
		String value = String.join(", ", parameter); // C, Java
		ps.setString(i, value);
	}

	/**
	 * varchar -> string[]
	 */
	@Override
	public String[] getNullableResult(ResultSet rs, String columnName) throws SQLException {
		String value = rs.getString(columnName);
		return value != null ? value.split(",") : null;
	}

	@Override
	public String[] getNullableResult(ResultSet rs, int columnIndex) throws SQLException {
		String value = rs.getString(columnIndex);
		return value != null ? value.split(",") : null;
	}

	@Override
	public String[] getNullableResult(CallableStatement cs, int columnIndex) throws SQLException {
		String value = cs.getString(columnIndex);
		return value != null ? value.split(",") : null;
	}

}

```



#### Member DTO

```java
package com.kh.spring.member.model.dto;

import java.time.LocalDate;
import java.time.LocalDateTime;

import org.springframework.format.annotation.DateTimeFormat;

import com.kh.spring.demo.model.dto.Gender;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.NonNull;

@Data // @Data(@Getter, @Setter, @ToString, @EqualsAndHashCode, @RequiredArgsConstructor 포함)
@NoArgsConstructor
@AllArgsConstructor
public class Member {
	@NonNull
	private String memberId;
	@NonNull
	private String password;
	@NonNull
	private String name;
	private Gender gender;
	@DateTimeFormat(pattern = "yyyy-MM-dd")
	private LocalDate birthday;
	private String email;
	@NonNull // 필드에 직접 어노테이션을 붙여 not null 설정
	private String phone;
	private String address;
	private String[] hobby;
	private LocalDateTime createdAt;
	private LocalDateTime updatedAt;
	private boolean enabled; // db에는 1,0으로 true,false
}
```



###### LocalDate, LocalDateTime,@DateTimeFormat

- LocalDate

  - 날짜 정보만 필요할 때 사용

  - ```java
    LocalDate currentDate = LocalDate.now();
    LocalDate targetDate = LocalDate.of(2019,11,12);
    // 결과 : 2019-11-12
    ```

- LocalDateTime

  - 날짜와 시간 정보 모두 필요할 때 사용

  - ```java
    / 로컬 컴퓨터의 현재 날짜와 시간 정보
    LocalDateTime currentDateTime = LocalDateTime.now();    
    // 결과 : 2019-11-12T16:34:30.388
    
    LocalDateTime targetDateTime = LocalDateTime.of(2019, 11, 12, 12, 32,22,3333);
    // 여기도 second,nanoSecond 매개변수는 필수가 아닌 선택입니다.
    // 결과 : 2019-11-12T12:32:22.000003333
    ```

- @DateTimeFormat(pattern = "yyyy-MM-dd")

  - db에서 String으로 들어오는 날짜 정보를 해당 형식으로 바꿔 날짜 관련 타입으로 바꾸어 줄 때 사용.



#### Modal(bootstrap)

부트스트랩에서 모달 코드를 넣고 실행하려면 스크립트 태그 안에 아래 코드를 작성해주어야 작동된다.

```java
<script>
$(loginModal).modal()
		// hide.bs.modal은 bootstrap에서 만든 것.
		.on("hide.bs.modal", (e) => {
			location.href = "${pageContext.request.contextPath}";
		});
</script>
```



#### view 단

###### \<jsp:include>

현재 페이지에 다른 파일을 가져올 수 있다.

```java
<jsp:include page="/WEB-INF/views/common/header.jsp">
	<jsp:param value="회원등록" name="title"/>
</jsp:include>
```



#### Spring AOP(Aspect Oriented Progarmming)

{: .notice--info}

관점지향 프로그래밍, 관심사의 분리해서 필요한 주업무에 모듈 형식으로 삽입해 실행.



###### 개념

AOP는 OOP를 대신하는 새로운 개념이 아니라, OOP를 더욱 OOP 답게 사용할 수 있도록 도와주는 개념이다.

- 객체를 재사용함으로써, 개발자들은 반복되는 코드를 줄였지만, 매 요청마다 로그, 권한 체크, 인증, 예외 처리 등 필수 요소는 반복 될 수 밖에 없음
- AOP를 통해, 비지니스 로직과 공통 모듈로 구분한 후에 비지니스 로직 코드 외부에서 필요한 시점에 공통 모듈을 삽입하여 실행하게 함.
- 기존 프로그래밍에서 각 객체별로 처리했던 것을 AOP에서는 각 관점별로 외부에서 접근해 처리하게 됨
- 즉 개발자는 계정, 게시판, 계좌이체와 같은 주업무 기능과, 공통적인 관심을 처리하는 보조 업무 기능을 각각 모듈로써 분리/개발한 후, 필요한 시점에 자동으로 소스코드가 삽입되도록 함.



**Aspect**(Advice와 pointcut을 작성하는 클래스 느낌이다.)

- 구현하고자 하는 횡단 관심사의 기능. 클래스 단위, 한개 이상의 Pointcut과 Advice의 조합으로 만들어진다.



**Joinpoint**(주 업무 로직의 메소드)

- 관점을 삽입하여 Advice가 적용될 수 있는 위치로써, 주업무 처리 메소드를 가리킨다.
- 대표적인 조인 포인트
  - 메소드가 호출되는 부분 또는 리턴되는 부분
  - 인스턴스가 만들어지는 지점
  - 예외가 던져지는 지점
  - 클래스가 초기화 되는 곳



**Pointcut**(어디에 삽입 결정)

- 어느 클래스의 어떤 메소드, 어느 joinpoint에 사용할 것인가?
- AOP에서는 포인트컷을 수행할 수 있는 다양한 접근 방법을 제공하는데, AspectJ에서는 와일드카드를 이용한 메쏘드 시그니처를 사용한다. 
- `execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern) throws-pattern?)`



**Advice**(처리할 부가 업무)

- 각 조인포인트에 삽입되어져 동작할 수 있는 코드
- 주로 메소드 단위로 구성된 어드바이스는 포인트컷에 의해 결정된 모듈의 조인포인트에서 호출되어 사용됨
- 일반적으로 독립적인 클래스 등으로 구현된 횡단 관심 모듈을 조인포인트의 정보를 참조해서 이용하는 방식으로 작성된다.
- Advice 종류
  - Before Advice : joinpoint 전에 실행
  - Around Advice : joinpoint 앞과 뒤에서 실행, 위치가 자유롭다
  - After Returning Advice : joinpoint 메소드가 리턴될 시 실행. return 된 object에 접근 가능
  - After Advice : jointpoint 후에 무조건 실행됨
  - After Throwing Advice : joinpoint 메소드 실행 중 예외 발생시 실행



**Weaving**

pointcut에 의해서 결정된 jointpoint에 지정된 Advice를 삽입하는 과정

- weaving 하는 3가지 방법
  - 컴파일 시에 
  - 클래스 로딩 시에
  - 런타임 시에





###### 선언식에서의 표현

`<aop:config>` 태그 몸체에서 작성하고, advisor 태그 혹은 aspect태그로 작성할 수 있음

1. `<aop:advisor>` : 1 advice + 1 pointcut

   - pointcut : 상기 표현식으로 joinpoint를 선정함

   - pointcut-ref : 선언된 pointcut을 이름으로 참조함

   - ```java
     <aop:config>
       	<aop:advisor
       		pointcut="com.xyz.someapp.SystemArchitecture.businessService()"
       		advice-ref="some-advice"/>
     </aop:config>
     ```

2. `<aop:aspect>` : multiple pointcut + multiple advice

   - aop:aspect는 등록된 특정 Aspect빈(클래스)을 참조함.(@Aspect 어노테이션 선언과 동일함.)

   - ```java
      <aop:config>
       	<aop:aspect id="loggerAspect" ref="loggerAspect">
       		<aop:pointcut expression="execution(* com.kh.spring.memo..*(..))" id="pc"/>
       		<aop:around method="aroundAdvice" pointcut-ref="pc"/>
       		<aop:before method="beforeAdvice" pointcut-ref="pc"/>
       	</aop:aspect>
     </aop:config>
     ```

3. `<aop:pointcut>` : pointcut 표현식 이용

   - ```java
     <aop:config>
      	<aop:pointcut id="businessService"
      		expression="execution(* com.xyz.myapp.service.*.*(..))"/>
      </aop:config>





###### Pointcut 선언

Pointcut은 Aspectj를 통해 와일드카드를 이용한 다음 표현식을 지원함.(&&, ||, !(부정)를 지원함.)



1. execution pointcut designator

   `execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern) throws-pattern?)`

```java
@Pointcut("execution(public * *(..))")
private void anyPublicOperation() {}
```



2. within pointcut designator

   ```java
   @Pointcut("within(com.xyz.someapp.trading..*)")
   private void inTrading() {}
   ```

   

3. name pointcut designator(다른 pointcut을 이름으로 참조함)

   ```java
   @Pointcut("anyPublicOperation() && inTrading()")
   private void tradingOperation() {}
   ```

   

<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/aop.html#aop-pointcuts-examples">pointcut 예제</a>





#### BoardEntity



#### 마이바티스 페이징 처리

RowBounds 객체 사용



파일 업로드



#### 토비의 스프링 공부

###### How to Study

{: .notice -- info}

스프링을 직접 사용해서 개발을 해야 하는 단계
핵심을 파악할 것
=> IoC 컨테이너, AOP, 추상화 계층(MVC, JDBC, Resource, O/X M, O/J M 등등)
=> 예제 코드 하나씩은 직접 짜볼 것
=> 이거 이해하고 짜보는데 그 두꺼운 책이나 레퍼런스를 다 읽을 필요가 없다.
취업이 목표라면 이정도 단계여도 하는데 문제는 없다.
토비의 스프링을 전부 보는게 아니라 필요한 부분만 보는 것
=> Controller의 계층구조는 상속구조로 만드는 내용 같은건 스킵 하는게 좋다.
이정도까지 공부하면 누구한테도 설명이 가능한 정도



##### 오브젝트와 의존관계

###### 포인트

1. 어플리케이션에서 오브젝트가 생성되고 다른 오브젝트와 관계를 맺고, 사용되고, 소멸되기까지의 전 과정을 공부해보자

2. 오브젝트는 어떻게 설계되어야 하는지, 어떤 단위로 만들어지며 어떤 과정을 통해 자신의 존재를 드러내고 등장해야 되는지 공부

   

###### 초난감 DAO	

자바빈

- 디폴트 생성자 : 자바빈은 파라미터가 없는 디폴트 생성자를 갖고 있어야 한다. 툴이나 프레임워크에서 리플렉션을 이용해 오브젝트를 생성하기 때문에 필요하다.
- 프로퍼티 : 자바빈이 노출하는 이름을 가진 속성을 프로퍼티라고 한다. 프로퍼티는 set으로 시작하는 setter와 get으로 시작하는 getter를 이용해 수정 또는 조회할 수 있다.



JDBC를 이용하는 작업의 일반적인 순서

1. DB 연결을 위한 Connection을 가져온다.
2. SQL을 담은 Statement(PreparedStatement)를 만든다.
3. 만들어진 Statement를 실행
4. 조회의 경우 sql 쿼리의 실행결과를 ResultSet으로 받아서 정보를 저장할 오브젝트에 옮겨준다.
5. 작업 중에 생성된 Connection, Statement, ResultSet 같은 리소스는 작업을 마친 후 반드시 닫아준다.
6. JDBC API가 만들어내는 예외를 잡아서 직접 처리하거나, 메소드에 throws를 선언하여 예외가 발생하면 메소드 밖으로 던지게 한다.



###### DAO의 분리

리펙토링

리펙토링은 기존의 코드를 외부의 동작방식에는 변화 없이 내부 구조를 변경해서 재구성하는 작업 또는 기술을 말한다. -> 생산성, 코드 품질, 유지보수에 유리



템플릿 메소드 패턴

​	상속을 통해 슈퍼클래스의 기능을 확장할 때 사용하는 가장 대표적인 방법. 변하지 않는 기능은 슈퍼클래스에 만들어두고 자주 변경되며 확장할 기능은 서브클래스에서 만들도록 한다.



###### 클래스의 분리









